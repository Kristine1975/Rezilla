<HTML>
<HEAD>
<TITLE></TITLE>
<META HTTP-EQUIV="content-type" CONTENT="text/html;charset=iso-8859-1">
<META NAME="generator" CONTENT="Aida Mode">
<META HTTP-EQUIV="Content-Language" CONTENT="fr-FR">
<META NAME="keywords" CONTENT="ressources, branches, Mac OS">
</HEAD>
<BODY>

<A HREF="index.html">Orig</A>&nbsp;&nbsp;|&nbsp;&nbsp;<A HREF="79.html">Prec</A>&nbsp;&nbsp;|&nbsp;&nbsp;<A HREF="81.html">Suiv</A><HR><P>&nbsp;</P>

<H3><A NAME="M113"></A>L'interface du plugin</H3><P>Les membres de l'interface du plugin sont définis dans le fichier d'en-tête <I>RezillaPluginInterface.h</I> qui se trouve dans le kit de développement de 
Rezilla (<I>Rezilla SDK</I>). Ce fichier doit être inclus dans le code
source du plugin. Il définit l'interface elle-même ainsi que quelques 
autres structures et énumérations qui régissent la communication entre 
l'application principale et les plugins.<P><H4><A NAME="M114"></A>La structure de l'interface</H4><P>L'interface est définie comme une structure composée de pointeurs de 
fonctions. C'est la liste de toutes les fonctions que le plugin doit 
définir pour implémenter l'interface. Ce sont les fonctions que Rezilla 
invoquera pour accomplir les différentes tâches relatives à l'édition 
d'une ressource.
<PRE>
typedef struct SPluginEditorInterface {
    IUNKNOWN_C_GUTS;
    Boolean  (*AcceptResource)(void *myInstance, ResType inType, short inID, Handle inDataH, RezPlugInfo * outInfo);
    OSErr    (*EditResource)(RezPlugRef inPlugref, RezHostInfo inInfo);
    Handle   (*ReturnResource)(RezPlugRef inPlugref, Boolean * outRelease, OSErr * outError);
    OSErr    (*RevertResource)(RezPlugRef inPlugref, Handle inDataH);
    Boolean  (*IsModified)(RezPlugRef inPlugref);
    void     (*CleanUp)(RezPlugRef inPlugref);
    void     (*Refresh)(RezPlugRef inPlugref);
    OSErr    (*ResizeBy)(RezPlugRef inPlugref, SInt16 inWidthDelta, SInt16 inHeightDelta);
    void     (*HandleMenu)(RezPlugRef inPlugref, MenuRef menu, SInt16 inMenuItem);
    void     (*HandleClick)(RezPlugRef inPlugref, const EventRecord * inMacEvent, Point inPortCoords);
    void     (*HandleKeyDown)(RezPlugRef inPlugref, const EventRecord * inKeyEvent);
    Boolean  (*HandleCommand)(RezPlugRef inPlugref, SInt16 inCommand);
}
</PRE><P>Cette structure donne les protopypes des fonctions. Le symbole 
<TT>IUNKNOWN_C_GUTS</TT> est une macro définie dans le fichier d'en-tête 
<I>CFPlugInCOM.h</I> et qui se développe en trois prototypes de fonctions
qui doivent impérativement figurer dans l'interface: <I>QueryInterface, 
AddRef</I>, et <I>Release</I>. Elles forment la base de l'architecture 
COM: n'importe quel plugin qui se conforme à ce modèle doit les définir. 
C'est là que les vérifications préliminaires ont lieu: par exemple, 
l'application identifie le plugin et vérifie que les UUIDs sont bien ceux 
que l'on attend. Voici les prototypes des trois fonctions COM:<P><PRE>
	HRESULT (*QueryInterface)(void *thisPointer, REFIID iid, LPVOID *ppv); \
	ULONG (*AddRef)(void *thisPointer); \
	ULONG (*Release)(void *thisPointer)
</PRE><P>Toutes les autres fonctions sont requises par Rezilla qui compte sur le plugin
pour les fournir. À l'exception de <I>AcceptResource</I>, le premier 
argument de toutes ces fonctions est un <I>RezPlugRef</I>: il s'agit 
d'une référence attribuée par le plugin à toute session d'édition de 
ressource, lors de la transaction initiale. Plus précisément, un
<I>RezPlugRef</I> est un pointeur sur des données clientes correspondant 
à la ressource à éditer: c'est cette référence qui identifie la ressource 
concernée ainsi que les données qui y sont attachées, car un plugin peut 
avoir plusieurs ressources à gérer simultanément. Rezilla n'intervient pas 
dans ces données clientes et se contente de passer le pointeur <I>RezPlugRef</I> dans tous 
les appels à une fonction du plugin. 
Le type d'un <I>RezPlugRef</I> est défini dans le fichier d'en-tête 
<I>RezillaPluginInterface.h</I> comme ceci:
<PRE>
	typedef void *	RezPlugRef;
</PRE><P>Lorsque le plugin est invoqué pour le première fois, Rezilla le charge en 
utilisant les fonctions adéquates de l'API CFPlugin. C'est à ce moment que 
la fonction de fabrication de l'interface est appelée: le nom de cette 
fonction est trouvé, comme indiqué précédemment dans la section 
<A HREF="#plugplist">Liste de propriétés du plugin</A>, dans le fichier de liste 
de propriétés <I>Info.plist</I>.<P><H4><A NAME="M115"></A>Interaction avec le plugin</H4>
Lorsque Rezilla doit éditer une ressource au moyen d'un plugin, une
transaction préliminaire a lieu entre les deux. Cette transaction s'exécute
en deux étapes qui font intervenir les fonctions <I>AcceptResource</I> et
<I>EditResource</I> successivement:
<OL>
	<LI> Rezilla invoque tout d'abord la fonction <I>AcceptResource</I> 
afin de demander au plugin s'il accepte d'éditer la ressource: il lui 
transmet le type, le numéro et l'adresse des données de la ressource afin 
qu'il puisse déterminer sa réponse. Si le plugin accepte la ressource, il 
remplit une structure de type <I>RezPlugInfo</I> que Rezilla lui a 
également passée en argument et dans laquelle il peut faire un certain 
nombre de requêtes: il peut par exemple demander à Rezilla d'insérer un ou
plusieurs menus dans la barre de menus.
C'est à ce moment que le plugin peut attribuer une référence <I>RezPlugRef</I>, c'est-à-dire un pointeur sur des données clientes, à cette 
nouvelle session d'édition et la transmettre à Rezilla qui, par la suite, la 
fera figurer dans toutes les autres fonctions de l'interface.<P>	<LI> après que Rezilla aura reçu l'acceptation du plugin et les requêtes de
celui-ci, la fonction <I>EditResource</I> sera invoquée. Par le biais de
cette fonction, le plugin reçoit une structure de type <I>RezHostInfo</I>
contenant des informations fournies par Rezilla: un pointeur <I>WindowRef</I> pour
identifier la fenêtre d'édition fournie par l'application, des pointeurs
<I>MenuRef</I> si jamais le plugin avait demandé l'insertion de menus, etc.
</OL><P>À ce stade, le plugin peut maintenant faire son travail d'édition de la
ressource. Il peut par exemple créer des contrôles et des éléments 
graphiques, installer des
CarbonEvents sur ces contrôles, etc. On notera dependant qu'il n'y a aucune
obligation à utiliser des CarbonEvents; toutes les actions et événements
déclenchés par l'utilisateur sont passés à Rezilla sous la forme d'un
EventRecord dans les fonctions suivantes définies dans l'interface:
<I>HandleMenu, HandleClick, HandleKeyDown</I> et <I>HandleCommand</I>.<P>Lorsque vient le moment de sauvegarder les modifications faites dans la ressource
 (par exemple lorsque l'utilisateur clique sur le bouton <I>Save</I> 
ou tente de fermer la fenêtre), 
Rezilla invoque la fonction <I>ReturnResource</I> afin que le plugin 
renvoie les données modifiées, puis la fonction <I>CleanUp</I> 
afin qu'il puisse exécuter les tâches qui mettent fin à une session 
d'édition, comme par exemple libérer les portions de mémoire qui ont été 
allouées.<P><H4><A NAME="M116"></A>Les requêtes du plugin</H4><P>Cette section donne plus de détails concernant les requêtes formulées par 
le plugin dans la fonction <I>AcceptResource</I>. La structure <I>RezPlugInfo</I> est définie comme ceci:
<PRE>
typedef struct RezPlugInfo {
    RezPlugRef    plugref;
    UInt32        attributes;
    Rect          winbounds;
    UInt8         menucount;
    MenuID *      menuIDs;
    OSErr         error;
}
</PRE><P>Le membre le plus important de cette structure est <I>attributes</I>:
il s'agit d'une valeur additive de type UInt32, somme de différents
drapeaux qui déterminent diverses caractéristiques de la fenêtre d'édition qui 
sera fournie par Rezilla ainsi que les commandes de base de Rezilla
qui seront supportées par le plugin. Les valeurs de ces drapeaux sont 
définies dans une énumération <I>RezillaPluginFlags</I> déclarée 
dans le fichier d'en-tête <I>RezillaPluginInterface.h</I>:
<PRE>
enum RezillaPluginFlags {
    kPluginNoAttributes             = 0L,
    
    kPluginEditorHasSaveButton      = (1L << 0),
    kPluginEditorHasCancelButton    = (1L << 1),
    kPluginEditorHasRevertButton    = (1L << 2),
    kPluginEditorHasLockIcon        = (1L << 3),
    kPluginEditorHasNameField       = (1L << 4),
    kPluginEditorStandardControls   = (kPluginEditorHasSaveButton 
                                   | kPluginEditorHasCancelButton 
                                   | kPluginEditorHasRevertButton 
                                   | kPluginEditorHasLockIcon),
    
    kPluginWinHasCollapseBox        = (1L << 5),
    kPluginWinIsResizable           = (1L << 6),
    
    kPluginSupportCut               = (1L << 10),
    kPluginSupportCopy              = (1L << 11),
    kPluginSupportPaste             = (1L << 12),
    kPluginSupportClear             = (1L << 13),
    kPluginSupportSelectAll         = (1L << 14),
    kPluginSupportFind              = (1L << 15),
    kPluginSupportFindNext          = (1L << 16),
    kPluginSupportImport            = (1L << 17),
    kPluginSupportExport            = (1L << 18),
    kPluginSupportEditCommands      = (kPluginSupportCut 
                                   | kPluginSupportCopy 
                                   | kPluginSupportPaste 
                                   | kPluginSupportClear)
}
</PRE><P>Le membre <I>winbounds</I> est une structure Rect indiquant la position et
dimension de la fenêtre d'édition. Rezilla fournit toujours une fenêtre
d'édition qui peut être équipée d'un certain nombre d'éléments de base tels
que des boutons <I>Save</I> et <I>Cancel</I>. Le plugin n'a pas à se
préoccuper de surveiller ces contrôles: ils sont gérés par l'application
principale. Le plugin doit simplement décider, au moyen des drapeaux
adéquats, lesquels de ces contrôles doivent figurer dans la fenêtre. Par
exemple, on ajoutera le drapeau <I>kPluginEditorHasRevertButton</I> aux
attributs si l'on souhaite avoir un bouton <I>Revert</I> dans la fenêtre.<P>Le membre <I>menucount</I> indique combien de menus sont nécessaires au
plugin (éventuellement 0). Si le plugin définit des menus, il doit passer
un tableau des MenuIDs correspondants dans le membre <I>menuIDs</I> de la
structure. Ces MenuIDs sont les numéros de ressources de type 'MENU' qui
devront se trouver dans le fichier de ressources du plugin: ce fichier de
ressources se trouve dans le sous-dossier <I>Resources</I> à l'intérieur
du paquetage (<I>bundle</I>) dans lequel se trouve le plugin, comme il a été expliqué
à la section <A HREF="#plugbundle">Anatomie du plugin</A> ci-dessus.<P>Dans le cas où le plugin n'accepte pas d'éditer une resource, il doit
renvoyer la valeur booléenne <I>false</I> comme valeur de retour de la
fonction <I>AcceptResource</I> et il n'est alors pas nécessaire de remplir
la structure de requêtes. Si une erreur se produit, le plugin peut
toutefois passer un code d'erreur dans le membre <I>error</I> de la
structure <I>RezPlugInfo</I>.<P><H4><A NAME="M117"></A>Les commandes supportées</H4>
Les menus de base de Rezilla (<I>File, Edit, Resources</I>) comportent des
commandes qui ne sont pas toujours activées: cela dépend du contexte. Par
exemple, la commande <I>Export</I> n'a de sens que dans certaines
circonstances ou avec certains types de ressources: de même, un plugin peut
décider de supporter cette commande ou pas. Les commandes ainsi supportées
par le plugin sont déclarées dans les attributs lors de la transaction
préliminaire comme il a été expliqué à la section précédente: si la
commande <I>Export</I> est supportée par le plugin, le drapeau <I>kPluginSupportExport</I> doit être ajouté aux attributs. Si ce drapeau
n'est pas mis, l'article de menu correspondant sera désactivé.<P>Par la suite, lorsque la commande <I>Export</I> du menu <I>File</I> est
invoquée par l'utilisateur, Rezilla appelle la fonction <I>HandleCommand</I> 
avec un numéro de commande correspondant afin que le plugin puisse
réagir en conséquence. Les numéros de commandes sont définis dans
l'énumération <I>RezillaPluginCmdIDs</I> déclarée dans le fichier
d'en-tête <I>RezillaPluginInterface.h</I>:
<PRE>
enum RezillaPluginCmdIDs {
    kPluginCommandCut        = 1,
    kPluginCommandCopy,
    kPluginCommandPaste,
    kPluginCommandClear,
    kPluginCommandSelectAll,
    kPluginCommandFind,
    kPluginCommandFindNext,
    kPluginCommandImport,
    kPluginCommandExport
}
</PRE><P><H4><A NAME="M118"></A>Informations de l'hôte</H4><P>La structure <I>RezHostInfo</I>  est définie comme ceci:
<PRE>
typedef struct RezHostInfo {
    CFBundleRef  bundleref;
    short        refnum;
    WindowRef    winref;
    UInt8        menucount;
    MenuRef *    menurefs;
    Rect         editrect;
    Boolean      readonly;
}
</PRE><P>C'est là que Rezilla passe des informations à destination du plugin. <P>Le membre <I>bundleref</I> de la structure est passé à titre de facilité:
c'est une référence de type <I>CFBundleRef</I> au paquetage du plugin pour le cas
où le plugin aurait besoin de trouver quelque chose à l'intérieur de sa
propre structure (des fichiers de localisation par exemple).<P>Le membre <I>refnum</I> est le numéro de référence de la table de 
ressources en mémoire à laquelle appartient la ressource en cours 
d'édition. Cela donne accès pour le plugin à diverses fonctions du 
Gestionnaire de ressources (<I>Resource Manager</I>): le plugin pourrait 
avoir besoin de trouver d'autres ressources dans la même table par 
exemple.<P>Le membre <I>winref</I> est le pointeur de type <I>WindowRef</I> de la fenêtre d'édition 
créée par Rezilla.<P>Le membre <I>menucount</I> indique combien de menus ont été créés par 
Rezilla. Ce devrait être le même nombre que celui demandé par le plugin 
dans la structure <I>RezillaPluginFlags</I>.
Le membre <I>menurefs</I> est un tableau de pointeurs de type <I>MenuRef</I>
correspondant aux différents menus.<P>Le membre <I>editrect</I> est une structure de type <I>Rect</I> indiquant les
coordonnées de la zone de contenu de la fenêtre d'édition qui peut être
utilisée par le plugin pour installer ses contrôles et éléments graphiques
sans dessiner par dessus des parties installées par Rezilla (comme par
exemple l'en-tête de la fenêtre ou la zone inférieure contenant les boutons
<I>Save</I> et <I>Cancel</I>). Ce <I>Rect</I> est exprimé dans le système de
coordonnées de la fenêtre.<P>Le membre <I>readonly</I> indique si la table à laquelle la ressource 
appartient est en lecture seule. Si elle l'est, il n'y a pas lieu 
d'autoriser des modifications: dans ce cas le plugin se comporte comme un simple 
visualisateur de contenu.<P><H4><A NAME="M119"></A>Codes d'erreur</H4><P>Rezilla définit des codes pour les principales erreurs susceptibles de se 
produire au cours d'une session d'édition par plugin. Ces codes commencent 
à la valeur 5000:
<PRE>
enum RezillaPluginErrors {
    plugErr_Generic                = 5000,    
    plugErr_InitializationFailed,
    plugErr_UnsupportedType,
    plugErr_UnsupportedID,
    plugErr_InvalidData,
    plugErr_UnsupportedResourceFormat,
    plugErr_UnsupportedResourceVersion,
    plugErr_EditResourceFailed,
    plugErr_ReturnResourceFailed,
    plugErr_RevertResourceFailed,
    plugErr_CantResizeWindow,
    plugErr_CantHandleMenuCommand,
    plugErr_LastError
}
</PRE><P>

</BODY>
</HTML>
