// ===========================================================================
// UAeteImportExport.cp					
// 
//                       Created : 2004-06-10 11:41:29
//             Last modification : 2006-10-03 18:30:28
// Author : Bernard Desgraupes
// e-mail : <bdesgraupes@users.sourceforge.net>
// www : <http://rezilla.sourceforge.net/>
// (c) Copyright : Bernard Desgraupes, 2004-2006
// All rights reserved.
// ===========================================================================

#ifdef PowerPlant_PCH
	#include PowerPlant_PCH
#endif

#include "UAeteImportExport.h"
#include "RezillaConstants.h"
#include "CAete_EditorDoc.h"
#include "CAete_EditorWindow.h"
#include "CAeteStream.h"
#include "CRezObj.h"
#include "CRezillaPrefs.h"
#include "CTextFileStream.h"
#include "CXMLFileStream.h"
#include "UMiscUtils.h"

#include <stdio.h>


PP_Begin_Namespace_PowerPlant


// ====================
// Class StAeteExporter
// ====================

// ---------------------------------------------------------------------------
//   StAeteExporter							Constructor		 	 [public]
// ---------------------------------------------------------------------------

StAeteExporter::StAeteExporter(CAete *	inAete,
							   FSSpec	inFileSpec,
							   SInt16	inFormat)
{	
	mAete = inAete;
	// Make a new file object
	if (inFormat == exportAete_Xml || inFormat == exportAete_Html || inFormat == exportAete_Sdef) {
		// UTF-8 output and escaped entities
		mFileStream = new CXMLFileStream(inFileSpec);
	} else {
		// MacRoman output
		mFileStream = new CTextFileStream(inFileSpec, kCFStringEncodingMacRoman);
	}
	mFormat = inFormat;
	mRezObj = nil;
}


// ---------------------------------------------------------------------------
//     ~StAeteExporter							Destructor			  [public]
// ---------------------------------------------------------------------------

StAeteExporter::~StAeteExporter()
{
	if (mFileStream != nil) {
		delete mFileStream;
	} 
}


// ---------------------------------------------------------------------------------
// WriteOut
// ---------------------------------------------------------------------------------
// All the cases should use the CAete* version of the functions. Only the
// Xml and Sdef formats have been rewritten so far. The others still use
// the stream version which is a waste of time since it assembles an aete 
// stream to parse it again.

void
StAeteExporter::WriteOut()
{
	if (mFileStream != nil) {
		// Get the proper file type.
		OSType	theFileType = 'TEXT';
		
		// Make new file on disk (we use TextEdit's creator).
		mFileStream->CreateNewDataFile( (OSType) CRezillaPrefs::GetPrefValue(kPref_export_editorSig), theFileType );
		
		// Open the data fork for writing
		mFileStream->OpenDataFork( fsWrPerm );
		
		// Export the data
		switch (mFormat) {
			case exportAete_Xml:
			WriteOutXml();
			break;
			
			case exportAete_Derez:
			WriteOutDerez();
			break;
			
			case exportAete_Sdef:
			WriteOutSdef();
			break;
			
			case exportAete_Text:
			WriteOutText();
			break;
			
			case exportAete_Html:
			WriteOutHtml();
			break;
		}
		
		// Close the data fork
		mFileStream->CloseDataFork();
	}	
}


// ---------------------------------------------------------------------------------
//  WriteOutXml
// ---------------------------------------------------------------------------------

void
StAeteExporter::WriteOutXml()
{
	UInt16		theCount,
				theSubCount,
				theSuiteCount,
				theEventCount,
				theClassCount,
				theCompOpCount,
				theEnumCount;
	UInt16		theLevel, theVersion;
	UInt16 		theFlags, replyFlags, directFlags;
	UInt16		i;
	OSType		theType, theCode, theReplyType, theDirectType;
	Str255 		theName, theDescr, replyDescr, directDescr;
	UInt8		theMajorVersion, theMinorVersion;
	SInt16		theLanguage, theScript;

	CXMLFileStream * theStream = dynamic_cast<CXMLFileStream *>(mFileStream);
	
	if (theStream == NULL) {
		return;
	} 
	
	theStream->WriteCStringNoEnc("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r");
	theStream->WriteCStringNoEnc("<!DOCTYPE AeteResource SYSTEM \"file://localhost/System/Library/DTDs/aete.dtd\">\r");

	if (mRezObj != nil) {
		LString::CopyPStr(*(mRezObj->GetName()), theName);
		theStream->WriteCStringNoEnc("<!--Generated by Rezilla from aete resource '");		
		*theStream << (SInt32) mRezObj->GetID();
		theStream->WriteCStringNoEnc("' - ");
		*theStream << theName;
		theStream->WriteCStringNoEnc("-->\r");		
	} 
	
	theStream->WriteTag("AeteResource", tag_open);

	// AETE INFO
	mAete->GetValues(theMajorVersion, theMinorVersion, theLanguage, theScript);
	theStream->WriteSInt32Enclosed( theMajorVersion, "MajorVersion", 1);
	theStream->WriteSInt32Enclosed( theMinorVersion, "MinorVersion", 1);
	theStream->WriteSInt32Enclosed( theLanguage, "LanguageCode", 1);
	theStream->WriteSInt32Enclosed( theScript, "ScriptCode", 1);

	theSuiteCount = mAete->CountSuites();
	
	if (theSuiteCount > 0) {
		TArrayIterator<CAeteSuite*> iteraror( *mAete->GetSuites() );
		CAeteSuite *	theSuite;
		
		theStream->WriteTag("ArraySuites", tag_open, true, 1);
		while (iteraror.Next(theSuite)) {
			theSuite->GetValues(theName, theDescr, theCode, theLevel, theVersion);
			
			theStream->WriteTag("Suite", tag_open, true, 2);
			theStream->WritePStringEnclosed(theName,"\pSuiteName", 3);
			theStream->WritePStringEnclosed(theDescr,"\pSuiteDescription", 3);
			theStream->WriteOSTypeEnclosed(theCode,"SuiteID", 3);
			theStream->WriteSInt32Enclosed(theLevel, "SuiteLevel", 3);
			theStream->WriteSInt32Enclosed(theVersion, "SuiteVersion", 3);

			// EVENTS	
			theEventCount = theSuite->CountEvents();
			if (theEventCount > 0) {
				TArrayIterator<CAeteEvent*> iterEv( *theSuite->GetEvents() );
				CAeteEvent *	theEvent;
				
				theStream->WriteTag("ArrayEvents", tag_open, true, 3);
				while (iterEv.Next(theEvent)) {
					
					theEvent->GetValues(theName, theDescr, theType, theCode, 
										theReplyType, replyDescr, replyFlags, 
										theDirectType, directDescr, directFlags);
					
					theStream->WriteTag("Event", tag_open, true, 4);
					theStream->WritePStringEnclosed(theName,"\pEventName", 5);
					theStream->WritePStringEnclosed(theDescr,"\pEventDescription", 5);
					theStream->WriteOSTypeEnclosed(theType, "EventClass", 5);
					theStream->WriteOSTypeEnclosed(theCode, "EventID", 5);
					theStream->WriteOSTypeEnclosed(theReplyType, "ReplyType", 5);
					theStream->WritePStringEnclosed(replyDescr,"\pReplyDescription", 5);
					
					// Reply flags
					theStream->WriteTag("ReplyFlags", tag_open, true, 5);					
					theStream->WriteBooleanEnclosed( ((replyFlags & (1 << kAEUTOptional)) > 0), "\pIsOptional", 6);
					theStream->WriteBooleanEnclosed( ((replyFlags & (1 << kAEUTlistOfItems)) > 0), "\pIsListOfItems", 6);
					theStream->WriteBooleanEnclosed( ((replyFlags & (1 << kAEUTEnumerated)) > 0), "\pIsEnumerated", 6);
					theStream->WriteBooleanEnclosed( ((replyFlags & (1 << kAEUTTightBindingFunction)) > 0), "\pTightBindingFunction", 6);
					theStream->WriteBooleanEnclosed( ((replyFlags & (1 << kAEUTEnumsAreTypes)) > 0), "\pEnumsAreTypes", 6);
					theStream->WriteBooleanEnclosed( ((replyFlags & (1 << kAEUTEnumListIsExclusive)) > 0), "\pEnumIsExclusive", 6);
					theStream->WriteBooleanEnclosed( ((replyFlags & (1 << kAEUTReplyIsReference)) > 0), "\pReplyIsReference", 6);
					for ( i = 1; i <= 5; i++) {
						theStream->WriteTag("Reserved", tag_empty, true, 6);
					}
					theStream->WriteBooleanEnclosed( ((replyFlags & (1 << aeut_NonVerbEvent)) > 0), "\pNonVerbEvent", 6);
					for ( i = 1; i <= 3; i++) {
						theStream->WriteTag("Reserved", tag_empty, true, 6);
					}
					theStream->WriteTag("ReplyFlags", tag_close, true, 5);
					
					theStream->WriteOSTypeEnclosed(theDirectType, "DirectParamType", 5);
					theStream->WritePStringEnclosed(directDescr,"\pDirectParamDescription", 5);
					
					// Direct flags
					theStream->WriteTag("DirectFlags", tag_open, true, 5);
					theStream->WriteBooleanEnclosed( ((directFlags & (1 << kAEUTOptional)) > 0), "\pIsOptional", 6);
					theStream->WriteBooleanEnclosed( ((directFlags & (1 << kAEUTlistOfItems)) > 0), "\pIsListOfItems", 6);
					theStream->WriteBooleanEnclosed( ((directFlags & (1 << kAEUTEnumerated)) > 0), "\pIsEnumerated", 6);
					theStream->WriteBooleanEnclosed( ((directFlags & (1 << kAEUTChangesState)) > 0), "\pChangeState", 6);
					theStream->WriteBooleanEnclosed( ((directFlags & (1 << kAEUTEnumsAreTypes)) > 0), "\pEnumsAreTypes", 6);
					theStream->WriteBooleanEnclosed( ((directFlags & (1 << kAEUTEnumListIsExclusive)) > 0), "\pEnumIsExclusive", 6);
					theStream->WriteBooleanEnclosed( ((directFlags & (1 << kAEUTDirectParamIsReference)) > 0), "\pDirectParamIsReference", 6);
					theStream->WriteBooleanEnclosed( ((directFlags & (1 << kAEUTNotDirectParamIsTarget)) > 0), "\pNotDirectParamIsTarget", 6);
					for ( i = 1; i <= 8; i++) {
						theStream->WriteTag("Reserved", tag_empty, true, 6);
					}
					theStream->WriteTag("DirectFlags", tag_close, true, 5);
					
					// ADDITIONAL PARAMETERS	
					theCount = theEvent->CountParameters();
					if (theCount) {
						TArrayIterator<CAeteParameter*> iterator( *theEvent->GetParameters() );
						CAeteParameter *	theParameter;
						
						theStream->WriteTag("ArrayOtherParams", tag_open, true, 5);
						while (iterator.Next(theParameter)) {
							theParameter->GetValues(theName, theCode, theType, theDescr, theFlags);
							
							theStream->WriteTag("Parameter", tag_open, true, 6);
							theStream->WritePStringEnclosed(theName,"\pParameterName", 7);
							theStream->WriteOSTypeEnclosed(theCode, "ParameterID", 7);
							theStream->WriteOSTypeEnclosed(theType, "ParameterType", 7);
							theStream->WritePStringEnclosed(theDescr,"\pParameterDescription", 7);
							
							// 	Parameter flags
							theStream->WriteTag("ParameterFlags", tag_open, true, 7);
							theStream->WriteBooleanEnclosed( ((theFlags & (1 << kAEUTOptional)) > 0), "\pIsOptional", 8);
							theStream->WriteBooleanEnclosed( ((theFlags & (1 << kAEUTlistOfItems)) > 0), "\pIsListOfItems", 8);
							theStream->WriteBooleanEnclosed( ((theFlags & (1 << kAEUTEnumerated)) > 0), "\pIsEnumerated", 8);
							theStream->WriteTag("Reserved", tag_empty, true, 8);
							theStream->WriteBooleanEnclosed( ((theFlags & (1 << kAEUTEnumsAreTypes)) > 0), "\pEnumsAreTypes", 8);
							theStream->WriteBooleanEnclosed( ((theFlags & (1 << kAEUTEnumListIsExclusive)) > 0), "\pEnumIsExclusive", 8);
							theStream->WriteBooleanEnclosed( ((theFlags & (1 << kAEUTParamIsReference)) > 0), "\pParamIsReference", 8);
							theStream->WriteBooleanEnclosed( ((theFlags & (1 << kAEUTParamIsTarget)) > 0), "\pParamIsTarget", 8);
							for ( i = 1; i <= 4; i++) {
								theStream->WriteTag("Reserved", tag_empty, true, 8);
							}
							theStream->WriteBooleanEnclosed( ((theFlags & (1 << aeut_LabeledParam)) > 0), "\pLabeledParam", 8);
							theStream->WriteBooleanEnclosed( ((theFlags & (1 << kAEUTFeminine)) > 0), "\pIsFeminine", 8);
							theStream->WriteBooleanEnclosed( ((theFlags & (1 << kAEUTMasculine)) > 0), "\pIsMasculine", 8);
							theStream->WriteBooleanEnclosed( ((theFlags & (1 << kAEUTPlural)) > 0), "\pPlural", 8);
							theStream->WriteTag("ParameterFlags", tag_close, true, 7);
				
							theStream->WriteTag("Parameter", tag_close, true, 6);
						}
						theStream->WriteTag("ArrayOtherParams", tag_close, true, 5);
					}
					theStream->WriteTag("Event", tag_close, true, 4);
				}
				theStream->WriteTag("ArrayEvents", tag_close, true, 3);
			}
			
			// CLASSES
			theClassCount = theSuite->CountClasses();
			if (theClassCount > 0) {
				TArrayIterator<CAeteClass*> iterCl( *theSuite->GetClasses() );
				CAeteClass *	theClass;
				
				theStream->WriteTag("ArrayClasses", tag_open, true, 3);
				while (iterCl.Next(theClass)) {
					theClass->GetValues(theName, theCode, theDescr);
					
					theStream->WriteTag("Class", tag_open, true, 4);
					theStream->WritePStringEnclosed(theName,"\pClassName", 5);
					theStream->WriteOSTypeEnclosed(theCode, "ClassID", 5);
					theStream->WritePStringEnclosed(theDescr,"\pClassDescription", 5);
					
					// CLASS PROPERTIES
					theCount = theClass->CountProperties();
					if (theCount) {
						TArrayIterator<CAeteProperty*> iterProp( *theClass->GetProperties() );
						CAeteProperty *	theProperty;
						
						theStream->WriteTag("ArrayProperties", tag_open, true, 5);
						while (iterProp.Next(theProperty)) {
							theProperty->GetValues(theName, theCode, theType, theDescr, theFlags);
							
							theStream->WriteTag("Property", tag_open, true, 6);
							
							theStream->WritePStringEnclosed(theName,"\pPropertyName", 7);
							theStream->WriteOSTypeEnclosed(theCode, "PropertyID", 7);
							theStream->WriteOSTypeEnclosed(theType, "PropertyClass", 7);
							theStream->WritePStringEnclosed(theDescr,"\pPropertyDescription", 7);
							
							// 	Parse flags
							theStream->WriteTag("PropertyFlags", tag_open, true, 7);
							theStream->WriteTag("Reserved", tag_empty, true, 8);
							theStream->WriteBooleanEnclosed( ((theFlags & (1 << kAEUTlistOfItems)) > 0), "\pIsListOfItems", 8);
							theStream->WriteBooleanEnclosed( ((theFlags & (1 << kAEUTEnumerated)) > 0), "\pIsEnumerated", 8);
							theStream->WriteBooleanEnclosed( ((theFlags & (1 << kAEUTReadWrite)) > 0), "\pIsReadWrite", 8);
							theStream->WriteBooleanEnclosed( ((theFlags & (1 << kAEUTEnumsAreTypes)) > 0), "\pEnumsAreTypes", 8);
							theStream->WriteBooleanEnclosed( ((theFlags & (1 << kAEUTEnumListIsExclusive)) > 0), "\pEnumIsExclusive", 8);
							theStream->WriteBooleanEnclosed( ((theFlags & (1 << kAEUTPropertyIsReference)) > 0), "\pPropertyIsReference", 8);
							for ( i = 1; i <= 5; i++)	theStream->WriteTag("Reserved", tag_empty, true, 8);
							theStream->WriteBooleanEnclosed( ((theFlags & (1 << kAEUTApostrophe)) > 0), "\pIsApostrophe", 8);
							theStream->WriteBooleanEnclosed( ((theFlags & (1 << kAEUTFeminine)) > 0), "\pIsFeminine", 8);
							theStream->WriteBooleanEnclosed( ((theFlags & (1 << kAEUTMasculine)) > 0), "\pIsMasculine", 8);
							theStream->WriteBooleanEnclosed( ((theFlags & (1 << kAEUTPlural)) > 0), "\pPlural", 8);
							theStream->WriteTag("PropertyFlags", tag_close, true, 7);
							
							theStream->WriteTag("Property", tag_close, true, 6);
						}
						theStream->WriteTag("ArrayProperties", tag_close, true, 5);
					} 
					
					// CLASS ELEMENTS
					theCount = theClass->CountElements();
					if (theCount) {
						TArrayIterator<CAeteElement*> iterElem( *theClass->GetElements() );
						CAeteElement *	theElement;
						
						theStream->WriteTag("ArrayElements", tag_open, true, 5);
						while (iterElem.Next(theElement)) {
							theType = theElement->GetID();				
							
							theStream->WriteTag("Element", tag_open, true, 6);
							theStream->WriteOSTypeEnclosed(theType, "ElementClass", 7);
			
							// KEY FORMS
							theSubCount = theElement->CountKeyForms();
							theStream->WriteTag("ArrayKeyForms", tag_open, true, 7);
							if (theSubCount) {
								TArrayIterator<OSType> iterator( *theElement->GetKeyForms() );
								OSType 	theKeyForm;
								
								while (iterator.Next(theKeyForm)) {
									theStream->WriteOSTypeEnclosed(theKeyForm, "KeyFormID", 8);
								}
							} 
							theStream->WriteTag("ArrayKeyForms", tag_close, true, 7);
							theStream->WriteTag("Element", tag_close, true, 6);
						}
						theStream->WriteTag("ArrayElements", tag_close, true, 5);
					}
					theStream->WriteTag("Class", tag_close, true, 4);
				}
				theStream->WriteTag("ArrayClasses", tag_close, true, 3);
			} 
			
			// COMPARISON OPERATORS
			theCompOpCount = theSuite->CountCompOps();
			if (theCompOpCount >0) {
				TArrayIterator<CAeteCompOp*> iterCo( *theSuite->GetCompOps() );
				CAeteCompOp *	theCompOp;
							
				theStream->WriteTag("ArrayComparisonOps", tag_open, true, 3);
				while (iterCo.Next(theCompOp)) {
					theCompOp->GetValues(theName, theCode, theDescr);
					
					theStream->WriteTag("ComparisonOp", tag_open, true, 4);
					theStream->WritePStringEnclosed(theName,"\pCompOpName", 5);
					theStream->WriteOSTypeEnclosed(theCode, "CompOpID", 5);
					theStream->WritePStringEnclosed(theDescr,"\pCompOpDescription", 5);
					theStream->WriteTag("ComparisonOp", tag_close, true, 4);
				}
				theStream->WriteTag("ArrayComparisonOps", tag_close, true, 3);
			} 		
			
			// ENUMERATIONS
			theEnumCount = theSuite->CountEnumerations();
			if (theEnumCount >0) {
				TArrayIterator<CAeteEnumeration*> iterEn( *theSuite->GetEnumerations() );
				CAeteEnumeration *	theEnumeration;
				
				theStream->WriteTag("ArrayEnumerations", tag_open, true, 3);
				while (iterEn.Next(theEnumeration)) {
					theCode = theEnumeration->GetEnumerationID();
					
					theStream->WriteTag("Enumeration", tag_open, true, 4);
					theStream->WriteOSTypeEnclosed(theCode, "EnumerationID", 5);
					
					// ENUMERATORS
					theCount = theEnumeration->CountEnumerators();
					if (theCount) {
						TArrayIterator<AeteEnumerator> iterator( *theEnumeration->GetEnumerators() );
						AeteEnumerator 	numerator;
						
						theStream->WriteTag("ArrayEnumerators", tag_open, true, 5);
						while (iterator.Next(numerator)) {
							theStream->WriteTag("Enumerator", tag_open, true, 6);
							theStream->WritePStringEnclosed(numerator.name,"\pEnumeratorName", 7);
							theStream->WriteOSTypeEnclosed(numerator.type, "EnumeratorID", 7);
							theStream->WritePStringEnclosed(numerator.description,"\pEnumeratorDescription", 7);
							theStream->WriteTag("Enumerator", tag_close, true, 6);
						}
						theStream->WriteTag("ArrayEnumerators", tag_close, true, 5);
					} 
					theStream->WriteTag("Enumeration", tag_close, true, 4);
				}
				theStream->WriteTag("ArrayEnumerations", tag_close, true, 3);
			} 		
			theStream->WriteTag("Suite", tag_close, true, 2);
		}
		theStream->WriteTag("ArraySuites", tag_close, true, 1);
	} 
	theStream->WriteTag("AeteResource", tag_close);
}


// ---------------------------------------------------------------------------------
//  WriteOutDerez
// ---------------------------------------------------------------------------------

void
StAeteExporter::WriteOutDerez()
{
	UInt16		index, 
				subindex, 
				theCount,
				theSubCount,
				theSuiteCount,
				theEventCount,
				theClassCount,
				theCompOpCount,
				theEnumCount,
				theSuiteIdx,
				theEventIdx,
				theClassIdx,
				theCompOpIdx,
				theEnumIdx;
	UInt16		i, theLevel, theVersion;
	UInt16 		theFlags, replyFlags, directFlags;
	OSType		theType, theCode, theReplyType, theDirectType;
	Str255 		theName, theDescr, replyDescr, directDescr;
	UInt8		theMajorVersion, theMinorVersion;
	SInt16		theLanguage, theScript;

	*mFileStream << "#include \"AEUserTermTypes.r\"\r\r";
	if (mRezObj != nil) {
		*mFileStream << "resource 'aete' (" << (SInt32) mRezObj->GetID() << ",\"";
		LString::CopyPStr(*(mRezObj->GetName()), theName);
		*mFileStream  << theName << "\") {\r";
	} else {
		*mFileStream << "resource 'aete' (0,\"\") {\r";
	}
	
	// AETE INFO
	mAete->GetValues(theMajorVersion, theMinorVersion, theLanguage, theScript);
	*mFileStream << "\t" << (SInt32) theMajorVersion << ",\r";
	*mFileStream << "\t" << (SInt32) theMinorVersion << ",\r";
	*mFileStream << "\t" << (SInt32) theLanguage << ",\r";
	*mFileStream << "\t" << (SInt32) theScript << ",\r";

	theSuiteCount = mAete->CountSuites();
	*mFileStream << "\t{\r";

	if (theSuiteCount > 0) {
		TArrayIterator<CAeteSuite*> iteraror( *mAete->GetSuites() );
		CAeteSuite *	theSuite;
		theSuiteIdx = 0;
		
		while (iteraror.Next(theSuite)) {
			theSuiteIdx++;
			theSuite->GetValues(theName, theDescr, theCode, theLevel, theVersion);
			
			*mFileStream << "\t\t\"" << theName << "\",\r";
			*mFileStream << "\t\t\"" << theDescr << "\",\r\t\t'";
			mFileStream->WriteOSType(theCode);
			*mFileStream << "',\r";
			*mFileStream << "\t\t" << (SInt32) theLevel << ",\r";
			*mFileStream << "\t\t" << (SInt32) theVersion << ",\r";
	
			// EVENTS	
			theEventCount = theSuite->CountEvents();
			*mFileStream << "\t\t{\r";

			if (theEventCount > 0) {
				TArrayIterator<CAeteEvent*> iterEv( *theSuite->GetEvents() );
				CAeteEvent *	theEvent;
				theEventIdx = 0;
				
				while (iterEv.Next(theEvent)) {
					theEventIdx++;
					
					theEvent->GetValues(theName, theDescr, theType, theCode, 
										theReplyType, replyDescr, replyFlags, 
										theDirectType, directDescr, directFlags);
					
					*mFileStream << "\t\t\t\"" << theName << "\",\r";
					*mFileStream << "\t\t\t\"" << theDescr << "\",\r\t\t\t'";
					mFileStream->WriteOSType(theType);
					*mFileStream << "',\r\t\t\t'";
					mFileStream->WriteOSType(theCode);
					*mFileStream << "',\r\t\t\t'";
					mFileStream->WriteOSType(theReplyType);
					*mFileStream << "',\r";
					
					// Reply
					*mFileStream << "\t\t\t\"" << replyDescr << "\",\r";
					
					// 	Parse reply's flags
					if (replyFlags & (1 << kAEUTOptional)) {
						*mFileStream << "\t\t\treplyOptional,\r";
					} else {
						*mFileStream << "\t\t\treplyRequired,\r";
					}
					if (replyFlags & (1 << kAEUTlistOfItems)) {
						*mFileStream << "\t\t\tlistOfItems,\r";
					} else {
						*mFileStream << "\t\t\tsingleItem,\r";
					}
					if (replyFlags & (1 << kAEUTEnumerated)) {
						*mFileStream << "\t\t\tenumerated,\r";
					} else {
						*mFileStream << "\t\t\tnotEnumerated,\r";
					}
					if (replyFlags & (1 << kAEUTTightBindingFunction)) {
						*mFileStream << "\t\t\ttightBindingFunction,\r";
					} else {
						*mFileStream << "\t\t\tnotTightBindingFunction,\r";
					}
					if (replyFlags & (1 << kAEUTEnumsAreTypes)) {
						*mFileStream << "\t\t\tenumsAreTypes,\r";
					} else {
						*mFileStream << "\t\t\tenumsAreConstants,\r";
					}
					if (replyFlags & (1 << kAEUTEnumListIsExclusive)) {
						*mFileStream << "\t\t\tenumListIsExclusive,\r";
					} else {
						*mFileStream << "\t\t\tenumListCanRepeat,\r";
					}
					if (replyFlags & (1 << kAEUTReplyIsReference)) {
						*mFileStream << "\t\t\treplyIsReference,\r";
					} else {
						*mFileStream << "\t\t\treplyIsValue,\r";
					}
					for ( i = 1; i <= 5; i++) {
						*mFileStream << "\t\t\treserved,\r";
					}
					if (replyFlags & (1 << aeut_NonVerbEvent)) {
						*mFileStream << "\t\t\tnonVerbEvent,\r";
					} else {
						*mFileStream << "\t\t\tverbEvent,\r";
					}
					for ( i = 1; i <= 3; i++) {
						*mFileStream << "\t\t\treserved,\r";
					}
				
					*mFileStream << "\t\t\t'" ;
					mFileStream->WriteOSType(theDirectType);
					*mFileStream << "',\r\t\t\t\"" << directDescr << "\",\r";
					
					// 	Parse direct parameter's flags
					if (directFlags & (1 << kAEUTOptional)) {
						*mFileStream << "\t\t\tdirectParamOptional,\r";
					} else {
						*mFileStream << "\t\t\tdirectParamRequired,\r";
					}
					if (directFlags & (1 << kAEUTlistOfItems)) {
						*mFileStream << "\t\t\tlistOfItems,\r";
					} else {
						*mFileStream << "\t\t\tsingleItem,\r";
					}
					if (directFlags & (1 << kAEUTEnumerated)) {
						*mFileStream << "\t\t\tenumerated,\r";
					} else {
						*mFileStream << "\t\t\tnotEnumerated,\r";
					}
					if (directFlags & (1 << kAEUTChangesState)) {
						*mFileStream << "\t\t\tchangesState,\r";
					} else {
						*mFileStream << "\t\t\tdoesntChangeState,\r";
					}
					if (directFlags & (1 << kAEUTEnumsAreTypes)) {
						*mFileStream << "\t\t\tenumsAreTypes,\r";
					} else {
						*mFileStream << "\t\t\tenumsAreConstants,\r";
					}
					if (directFlags & (1 << kAEUTEnumListIsExclusive)) {
						*mFileStream << "\t\t\tenumListIsExclusive,\r";
					} else {
						*mFileStream << "\t\t\tenumListCanRepeat,\r";
					}
					if (directFlags & (1 << kAEUTDirectParamIsReference)) {
						*mFileStream << "\t\t\tdirectParamIsReference,\r";
					} else {
						*mFileStream << "\t\t\tdirectParamIsValue,\r";
					}
					if (directFlags & (1 << kAEUTNotDirectParamIsTarget)) {
						*mFileStream << "\t\t\tnotDirectParamIsTarget,\r";
					} else {
						*mFileStream << "\t\t\tdirectParamIsTarget,\r";
					}
			
					for ( i = 1; i <= 8; i++) {
						*mFileStream << "\t\t\treserved,\r";
					}
					
					// ADDITIONAL PARAMETERS	
					theCount = theEvent->CountParameters();
					*mFileStream << "\t\t\t{\r";

					if (theCount) {
						TArrayIterator<CAeteParameter*> iterator( *theEvent->GetParameters() );
						CAeteParameter *	theParameter;
						index = 0;
						
						while (iterator.Next(theParameter)) {
							theParameter->GetValues(theName, theCode, theType, theDescr, theFlags);
							index++;
							
							*mFileStream << "\t\t\t\t\"" << theName << "\",\r\t\t\t\t'";
							mFileStream->WriteOSType(theCode);
							*mFileStream << "',\r\t\t\t\t'";					
							mFileStream->WriteOSType(theType);
							*mFileStream << "',\r";					
							*mFileStream << "\t\t\t\t\"" << theDescr << "\",\r";
								
							// 	Parse parameter's flags
							if (theFlags & (kAEUTParamIsReference << kAEUTOptional)) {
								*mFileStream << "\t\t\t\toptional,\r";
							} else {
								*mFileStream << "\t\t\t\trequired,\r";
							}
							if (theFlags & (kAEUTParamIsReference << kAEUTlistOfItems)) {
								*mFileStream << "\t\t\t\tlistOfItems,\r";
							} else {
								*mFileStream << "\t\t\t\tsingleItem,\r";
							}
							if (theFlags & (kAEUTParamIsReference << kAEUTEnumerated)) {
								*mFileStream << "\t\t\t\tenumerated,\r";
							} else {
								*mFileStream << "\t\t\t\tnotEnumerated,\r";
							}
							*mFileStream << "\t\t\t\treserved,\r";
							if (theFlags & (kAEUTParamIsReference << kAEUTEnumsAreTypes)) {
								*mFileStream << "\t\t\t\tenumsAreTypes,\r";
							} else {
								*mFileStream << "\t\t\t\tenumsAreConstants,\r";
							}
							if (theFlags & (kAEUTParamIsReference << kAEUTEnumListIsExclusive)) {
								*mFileStream << "\t\t\t\tenumListIsExclusive,\r";
							} else {
								*mFileStream << "\t\t\t\tenumListCanRepeat,\r";
							}
							if (theFlags & (kAEUTParamIsReference << kAEUTParamIsReference)) {
								*mFileStream << "\t\t\t\tparamIsReference,\r";
							} else {
								*mFileStream << "\t\t\t\tparamIsValue,\r";
							}
							if (theFlags & (kAEUTParamIsReference << kAEUTParamIsTarget)) {
								*mFileStream << "\t\t\t\tparamIsTarget,\r";
							} else {
								*mFileStream << "\t\t\t\tnotParamIsTarget,\r";
							}
							for ( i = 1; i <= 4; i++) {
								*mFileStream << "\t\t\t\treserved,\r";
							}
							if (theFlags & (1 << aeut_LabeledParam)) {
								*mFileStream << "\t\t\t\tlabeledParam,\r";
							} else {
								*mFileStream << "\t\t\t\tprepositionParam,\r";
							}
							if (theFlags & (1 << kAEUTFeminine)) {
								*mFileStream << "\t\t\t\tfeminine,\r";
							} else {
								*mFileStream << "\t\t\t\tnotFeminine,\r";
							}
							if (theFlags & (1 << kAEUTMasculine)) {
								*mFileStream << "\t\t\t\tmasculine,\r";
							} else {
								*mFileStream << "\t\t\t\tnotMasculine,\r";
							}
							if (theFlags & (1 << kAEUTPlural)) {
								*mFileStream << "\t\t\t\tplural\r";
							} else {
								*mFileStream << "\t\t\t\tsingular";
							}
							if (index < theCount) {
								*mFileStream << ",\r";
							} else {
								*mFileStream << "\r";
							}
						}
					}
					*mFileStream << "\t\t\t}";
					if (theEventIdx < theEventCount) {
						*mFileStream << ",\r";
					} else {
						*mFileStream << "\r";
					}
				}
			}
			*mFileStream << "\t\t},\r";

			// CLASSES
			theClassCount = theSuite->CountClasses();
			*mFileStream << "\t\t{\r";

			if (theClassCount > 0) {
				TArrayIterator<CAeteClass*> iterCl( *theSuite->GetClasses() );
				CAeteClass *	theClass;
				theClassIdx = 0;
				
				while (iterCl.Next(theClass)) {
					theClassIdx++;
					theClass->GetValues(theName, theCode, theDescr);
					
					*mFileStream << "\t\t\t\"" << theName << "\",\r\t\t\t'";
					mFileStream->WriteOSType(theCode);
					*mFileStream << "',\r\t\t\t\"" << theDescr << "\",\r";
					
					// CLASS PROPERTIES
					theCount = theClass->CountProperties();
					*mFileStream << "\t\t\t{\r";

					if (theCount) {
						TArrayIterator<CAeteProperty*> iterProp( *theClass->GetProperties() );
						CAeteProperty *	theProperty;
						index = 0;
						
						while (iterProp.Next(theProperty)) {
							index++;
							theProperty->GetValues(theName, theCode, theType, theDescr, theFlags);
							
							*mFileStream << "\t\t\t\t\"" << theName << "\",\r\t\t\t\t'";
							mFileStream->WriteOSType(theCode);
							*mFileStream << "',\r\t\t\t\t'";					
							mFileStream->WriteOSType(theType);
							*mFileStream << "',\r\t\t\t\t\"" << theDescr << "\",\r";
															
							// 	Parse flags
							*mFileStream << "\t\t\t\treserved,\r";
							if (theFlags & (1 << kAEUTlistOfItems)) {
								*mFileStream << "\t\t\t\tlistOfItems,\r";
							} else {
								*mFileStream << "\t\t\t\tsingleItem,\r";
							}
							if (theFlags & (1 << kAEUTEnumerated)) {
								*mFileStream << "\t\t\t\tenumerated,\r";
							} else {
								*mFileStream << "\t\t\t\tnotEnumerated,\r";
							}
							if (theFlags & (1 << kAEUTReadWrite)) {
								*mFileStream << "\t\t\t\treadWrite,\r";
							} else {
								*mFileStream << "\t\t\t\treadOnly,\r";
							}
							if (theFlags & (1 << kAEUTEnumsAreTypes)) {
								*mFileStream << "\t\t\t\tenumsAreTypes,\r";
							} else {
								*mFileStream << "\t\t\t\tenumsAreConstants,\r";
							}
							if (theFlags & (1 << kAEUTEnumListIsExclusive)) {
								*mFileStream << "\t\t\t\tenumListIsExclusive,\r";
							} else {
								*mFileStream << "\t\t\t\tenumListCanRepeat,\r";
							}
							if (theFlags & (1 << kAEUTPropertyIsReference)) {
								*mFileStream << "\t\t\t\tpropertyIsReference,\r";
							} else {
								*mFileStream << "\t\t\t\tpropertyIsValue,\r";
							}							
							for ( i = 1; i <= 5; i++) {
								*mFileStream << "\t\t\t\treserved,\r";
							}
							if (theFlags & (1 << kAEUTApostrophe)) {
								*mFileStream << "\t\t\t\tapostrophe,\r";
							} else {
								*mFileStream << "\t\t\t\tnoApostrophe,\r";
							}
							if (theFlags & (1 << kAEUTFeminine)) {
								*mFileStream << "\t\t\t\tfeminine,\r";
							} else {
								*mFileStream << "\t\t\t\tnotFeminine,\r";
							}
							if (theFlags & (1 << kAEUTMasculine)) {
								*mFileStream << "\t\t\t\tmasculine,\r";
							} else {
								*mFileStream << "\t\t\t\tnotMasculine,\r";
							}
							if (theFlags & (1 << kAEUTPlural)) {
								*mFileStream << "\t\t\t\tplural\r";
							} else {
								*mFileStream << "\t\t\t\tsingular";
							}
							if (index < theCount) {
								*mFileStream << ",\r";
							} else {
								*mFileStream << "\r";
							}
						}
					} 
					*mFileStream << "\t\t\t},\r";								
					
					// CLASS ELEMENTS
					theCount = theClass->CountElements();
					*mFileStream << "\t\t\t{\r";
					
					if (theCount) {
						TArrayIterator<CAeteElement*> iterElem( *theClass->GetElements() );
						CAeteElement *	theElement;
						index = 0;
						
						while (iterElem.Next(theElement)) {
							index++;
							theType = theElement->GetID();				
							
							*mFileStream << "\t\t\t\t'" ;					
							mFileStream->WriteOSType(theType);
							*mFileStream << "',\r";					

							// KEY FORMS
							theSubCount = theElement->CountKeyForms();
							*mFileStream << "\t\t\t\t{\r";
							
							if (theSubCount) {
								TArrayIterator<OSType> iterator( *theElement->GetKeyForms() );
								OSType 	theKeyForm;
								subindex = 0;
								
								while (iterator.Next(theKeyForm)) {
									subindex++;
									*mFileStream << "\t\t\t\t\t'";
									mFileStream->WriteOSType(theKeyForm);
									*mFileStream << "'";
									if (subindex < theSubCount) {
										*mFileStream << ",\r";
									} else {
										*mFileStream << "\r";
									}
								}
							} 
							*mFileStream << "\t\t\t\t}";
							if (index < theCount) {
								*mFileStream << ",\r";
							} else {
								*mFileStream << "\r";
							}
						}
					}
					*mFileStream << "\t\t\t}";
					if (theClassIdx < theClassCount) {
						*mFileStream << ",\r";
					} else {
						*mFileStream << "\r";
					}
				}
			} 
			*mFileStream << "\t\t},\r";

			// COMPARISON OPERATORS
			theCompOpCount = theSuite->CountCompOps();
			*mFileStream << "\t\t{\r";
			
			if (theCompOpCount >0) {
				TArrayIterator<CAeteCompOp*> iterCo( *theSuite->GetCompOps() );
				CAeteCompOp *	theCompOp;
				theCompOpIdx = 0;
				
				while (iterCo.Next(theCompOp)) {
					theCompOpIdx++;
					theCompOp->GetValues(theName, theCode, theDescr);
					
					*mFileStream << "\t\t\t\"" << theName << "\",\r\t\t\t'";
					mFileStream->WriteOSType(theCode);
					*mFileStream << "',\r\t\t\t\"" << theDescr << "\"";
					if (theCompOpIdx < theCompOpCount) {
						*mFileStream << ",\r";
					} else {
						*mFileStream << "\r";
					}
				}
			} 		
			*mFileStream << "\t\t},\r";

			// ENUMERATIONS
			theEnumCount = theSuite->CountEnumerations();
			*mFileStream << "\t\t{\r";
			
			if (theEnumCount >0) {
				TArrayIterator<CAeteEnumeration*> iterEn( *theSuite->GetEnumerations() );
				CAeteEnumeration *	theEnumeration;
				theEnumIdx = 0;
				
				while (iterEn.Next(theEnumeration)) {
					theEnumIdx++;
					theCode = theEnumeration->GetEnumerationID();
					
					*mFileStream << "\t\t\t'";					
					mFileStream->WriteOSType(theCode);
					*mFileStream << "',\r";					
		
					// ENUMERATORS
					theCount = theEnumeration->CountEnumerators();
					*mFileStream << "\t\t\t{\r";

					if (theCount) {
						TArrayIterator<AeteEnumerator> iterator( *theEnumeration->GetEnumerators() );
						AeteEnumerator 	numerator;
						index = 0;
						
						while (iterator.Next(numerator)) {
							index++;
							*mFileStream << "\t\t\t\t\"" << numerator.name << "\",\r\t\t\t\t'";
							mFileStream->WriteOSType(numerator.type);
							*mFileStream << "',\r\t\t\t\t\"" << numerator.description << "\"";
							if (index < theCount) {
								*mFileStream << ",\r";
							} else {
								*mFileStream << "\r";
							}
						}
					} 
					*mFileStream << "\t\t\t}";
					if (theEnumIdx < theEnumCount) {
						*mFileStream << ",\r";
					} else {
						*mFileStream << "\r";
					}
				}
			} 					
			*mFileStream << "\t\t}";
			if (theSuiteIdx < theSuiteCount) {
				*mFileStream << ",\r";
			} else {
				*mFileStream << "\r";
			}
		}
	} 
	*mFileStream << "\t}\r";
	// Close the aete resource statement
	*mFileStream << "};\r";
}


// ---------------------------------------------------------------------------------
//  WriteOutSdef
// ---------------------------------------------------------------------------------
// Note:
// * currently no attempt is made to handle special chars like the < and > 
//    symbols, ampersands etc. We should probably support at least the 5
//    predefined entities (lt, gt, quot, amp, apos) like CFXMLParser.
// * "man sdef" says that hexadecimal values can be used for codes:
// 			A code may be specified as a hex constant, 
// 			e.g. ``0x1234abcd'', if some of the characters 
// 			are unprintable.

void
StAeteExporter::WriteOutSdef()
{
	UInt16		theCount,
				theSubCount,
				theEventCount,
				theClassCount,
				theEnumCount;
	UInt16		theLevel, theVersion;
	UInt16 		theFlags, replyFlags, directFlags;
	OSType		theType, theCode, theReplyType, theDirectType;
	Str255 		theName, theDescr, replyDescr, directDescr;
	Boolean		isOptional, isReadWrite;
	
	CXMLFileStream * theStream = dynamic_cast<CXMLFileStream *>(mFileStream);
	
	if (theStream == NULL) {
		return;
	} 
	
	theStream->WriteCStringNoEnc("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r");
	theStream->WriteCStringNoEnc("<!DOCTYPE dictionary SYSTEM \"file://localhost/System/Library/DTDs/sdef.dtd\">\r");
	if (mRezObj != nil) {
		theStream->WriteCStringNoEnc("<!--Scripting definition file generated from aete resource '");
		*theStream << (SInt32) mRezObj->GetID();
		theStream->WriteCStringNoEnc("' - ");
		*theStream << *(mRezObj->GetName());
		theStream->WriteCStringNoEnc("-->\r");
	} 
	
	theStream->WriteTag("dictionary", tag_open);
	TArrayIterator<CAeteSuite*> iteraror( *mAete->GetSuites() );
	CAeteSuite *	theSuite;
	
	while (iteraror.Next(theSuite)) {
		theSuite->GetValues(theName, theDescr, theCode, theLevel, theVersion);
		
		theStream->WriteCStringNoEnc("\t<suite name=\"");
		*theStream << theName;
		theStream->WriteCStringNoEnc("\" code=\"");
		theStream->WriteOSType(theCode);
		theStream->WriteCStringNoEnc("\" description=\"");
		*theStream << theDescr;
		theStream->WriteCStringNoEnc("\">\r");
		
		// ENUMERATIONS
		theEnumCount = theSuite->CountEnumerations();
		if (theEnumCount >0) {
			TArrayIterator<CAeteEnumeration*> iterEn( *theSuite->GetEnumerations() );
			CAeteEnumeration *	theEnumeration;
			
			theStream->WriteTag("types", tag_open, true, 2);
			while (iterEn.Next(theEnumeration)) {
				theCode = theEnumeration->GetEnumerationID();
				
				theStream->WriteCStringNoEnc("\t\t\t<enumeration name=\"");
				// Enumerations don't have name, use the code instead. 
				// Name is required by sdef.dtd.
				theStream->WriteOSType(theCode);
				theStream->WriteCStringNoEnc("\" code=\"");
				theStream->WriteOSType(theCode);
				theStream->WriteCStringNoEnc("\">\r");
				
				// ENUMERATORS
				theCount = theEnumeration->CountEnumerators();
				if (theCount) {
					TArrayIterator<AeteEnumerator> iterator( *theEnumeration->GetEnumerators() );
					AeteEnumerator 	numerator;
					
					while (iterator.Next(numerator)) {
						theStream->WriteCStringNoEnc("\t\t\t\t<enumerator name=\"");
						*theStream << numerator.name;
						theStream->WriteCStringNoEnc("\" code=\"");
						theStream->WriteOSType(numerator.type);
						theStream->WriteCStringNoEnc("\" description=\"");
						*theStream << numerator.description;
						theStream->WriteCStringNoEnc("\"/>\r");
					}
				} 
				theStream->WriteTag("enumeration", tag_close, true, 3);
			}
			theStream->WriteTag("types", tag_close, true, 2);
		} 		
		
		// CLASSES
		theClassCount = theSuite->CountClasses();
		if (theClassCount > 0) {
			TArrayIterator<CAeteClass*> iterCl( *theSuite->GetClasses() );
			CAeteClass *	theClass;
			
			theStream->WriteTag("classes", tag_open, true, 2);
			while (iterCl.Next(theClass)) {
				theClass->GetValues(theName, theCode, theDescr);
				
				theStream->WriteCStringNoEnc("\t\t\t<class name=\"");
				*theStream << theName;
				theStream->WriteCStringNoEnc("\" code=\"");
				theStream->WriteOSType(theCode);
				theStream->WriteCStringNoEnc("\" description=\"");
				*theStream << theDescr;
				theStream->WriteCStringNoEnc("\">\r");
				// plural ? inherits ?
				
				// CLASS ELEMENTS
				theCount = theClass->CountElements();
				if (theCount) {
					TArrayIterator<CAeteElement*> iterElem( *theClass->GetElements() );
					CAeteElement *	theElement;
					
					theStream->WriteTag("elements", tag_open, true, 4);
					while (iterElem.Next(theElement)) {
						theType = theElement->GetID();				
						
						theStream->WriteCStringNoEnc("\t\t\t\t\t<element type=\"");
						ConvertToSdefType(theStream, theType, 0);
						theStream->WriteCStringNoEnc("\">\r");
						
						// KEY FORMS
						theSubCount = theElement->CountKeyForms();
						if (theSubCount) {
							TArrayIterator<OSType> iterator( *theElement->GetKeyForms() );
							OSType 	theKeyForm;
							
							while (iterator.Next(theKeyForm)) {
								theStream->WriteCStringNoEnc("\t\t\t\t\t\t<accessor style=\"");
								ConvertToSdefForm(theStream, theKeyForm);
								theStream->WriteCStringNoEnc("\"/>\r");
							}
						} 
						theStream->WriteTag("element", tag_close, true, 5);
					}
					theStream->WriteTag("elements", tag_close, true, 4);
				}
				
				// CLASS PROPERTIES
				theCount = theClass->CountProperties();
				if (theCount) {
					TArrayIterator<CAeteProperty*> iterProp( *theClass->GetProperties() );
					CAeteProperty *	theProperty;
					
					theStream->WriteTag("properties", tag_open, true, 4);
					while (iterProp.Next(theProperty)) {
						theProperty->GetValues(theName, theCode, theType, theDescr, theFlags);
						
						theStream->WriteCStringNoEnc("\t\t\t\t\t<property name=\"");
						*theStream << theName;
						theStream->WriteCStringNoEnc("\" code=\"");
						theStream->WriteOSType(theCode);
						theStream->WriteCStringNoEnc("\" type=\"");
						ConvertToSdefType(theStream, theType, theFlags);
						theStream->WriteCStringNoEnc("\"");
						
						// 	Property flags
						isReadWrite = ( (theFlags & (1 << kAEUTReadWrite)) > 0 );
						if ( isReadWrite ) {
							theStream->WriteCStringNoEnc(" access=\"rw\"");
						} else {
							theStream->WriteCStringNoEnc(" access=\"r\"");
						}
						
						theStream->WriteCStringNoEnc(" description=\"");
						*theStream << theDescr;
						theStream->WriteCStringNoEnc("\"");
						theStream->WriteCStringNoEnc(">\r");
						theStream->WriteTag("property", tag_close, true, 5);
						// attribute "hidden" ???
					}
					theStream->WriteTag("properties", tag_close, true, 4);
				} 
				theStream->WriteTag("class", tag_close, true, 3);
			}
			theStream->WriteTag("classes", tag_close, true, 2);
		} 
		
		// EVENTS	
		theEventCount = theSuite->CountEvents();
		if (theEventCount > 0) {
			TArrayIterator<CAeteEvent*> iterEv( *theSuite->GetEvents() );
			CAeteEvent *	theEvent;
			
			theStream->WriteTag("commands", tag_open, true, 2);
			while (iterEv.Next(theEvent)) {
				
				theEvent->GetValues(theName, theDescr, theType, theCode, 
									theReplyType, replyDescr, replyFlags, 
									theDirectType, directDescr, directFlags);
				
				theStream->WriteCStringNoEnc("\t\t\t<command name=\"");
				*theStream << theName;
				theStream->WriteCStringNoEnc("\" code=\"");
				theStream->WriteOSType(theType);
				theStream->WriteOSType(theCode);
				theStream->WriteCStringNoEnc("\" description=\"");
				*theStream << theDescr;
				theStream->WriteCStringNoEnc("\">\r");
				
				theStream->WriteCStringNoEnc("\t\t\t\t<direct-parameter type=\"");
				theStream->WriteOSType(theDirectType);
				theStream->WriteCStringNoEnc("\" description=\"");
				*theStream << directDescr;
				theStream->WriteCStringNoEnc("\"");
				
				// 	Direct parameter's flags
				isOptional = ( (directFlags & (1 << kAEUTOptional)) > 0 );
				if (isOptional) {
					theStream->WriteCStringNoEnc(" optional=\"optional\"");
				} 
				theStream->WriteCStringNoEnc("/>\r");
				
				theStream->WriteCStringNoEnc("\t\t\t\t<result type=\"");
				theStream->WriteOSType(theReplyType);
				theStream->WriteCStringNoEnc("\" description=\"");
				*theStream << replyDescr;
				theStream->WriteCStringNoEnc("\"/>\r");
				
				// ADDITIONAL PARAMETERS	
				theCount = theEvent->CountParameters();
				if (theCount) {
					TArrayIterator<CAeteParameter*> iterator( *theEvent->GetParameters() );
					CAeteParameter *	theParameter;
					
					while (iterator.Next(theParameter)) {
						theParameter->GetValues(theName, theCode, theType, theDescr, theFlags);
						
						theStream->WriteCStringNoEnc("\t\t\t\t<parameter name=\"");
						*theStream << theName;
						theStream->WriteCStringNoEnc("\" code=\"");
						theStream->WriteOSType(theCode);
						theStream->WriteCStringNoEnc("\" type=\"");
						ConvertToSdefType(theStream, theType, theFlags);
						theStream->WriteCStringNoEnc("\" description=\"");
						*theStream << theDescr;
						theStream->WriteCStringNoEnc("\"");
						
						// 	Parameter flags
						isOptional = ( (theFlags & (1 << kAEUTOptional)) > 0 );
						if (isOptional) {
							theStream->WriteCStringNoEnc(" optional=\"optional\"");
						} 
						theStream->WriteCStringNoEnc(">\r");
						theStream->WriteTag("parameter", tag_close, true, 4);
						// attribute "hidden" ???
					}
				}
				theStream->WriteTag("command", tag_close, true, 3);
			}
			theStream->WriteTag("commands", tag_close, true, 2);
		}
		
		theStream->WriteTag("suite", tag_close, true, 1);
	}
	theStream->WriteTag("dictionary", tag_close);
}


// ---------------------------------------------------------------------------------
//  WriteOutHtml
// ---------------------------------------------------------------------------------

void
StAeteExporter::WriteOutHtml()
{
	UInt16		theCount,
				theSubCount,
				theSuiteCount,
				theEventCount,
				theClassCount,
				theCompOpCount,
				theEnumCount;
	UInt16		theLevel, theVersion;
	UInt16 		theFlags, replyFlags, directFlags;
	OSType		theType, theCode, theReplyType, theDirectType;
	Str255 		theName, theDescr, replyDescr, directDescr;
	UInt8		theMajorVersion, theMinorVersion;
	SInt16		theLanguage, theScript;
	
	CXMLFileStream * theStream = dynamic_cast<CXMLFileStream *>(mFileStream);
	
	if (theStream == NULL) {
		return;
	} 
	
	theStream->WriteCStringNoEnc("<HTML>\r<HEAD>\r<TITLE>AppleScript Terminology</TITLE>\r");
	theStream->WriteCStringNoEnc("<META NAME=GENERATOR CONTENT=\"Rezilla\">\r");
	theStream->WriteCStringNoEnc("<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\r");
	theStream->WriteCStringNoEnc("</HEAD>\r<BODY>\r<DL>\r");
	
	if (mRezObj != nil) {
		LString::CopyPStr(*(mRezObj->GetName()), theName);
		theStream->WriteCStringNoEnc("\t<DT>Aete resource '");
		*theStream << (SInt32) mRezObj->GetID();
		theStream->WriteCStringNoEnc("' ");
		*theStream << theName << "\r";
	}
	
	mAete->GetValues(theMajorVersion, theMinorVersion, theLanguage, theScript);
	theStream->WriteCStringNoEnc("\r\t<DT>Version: ");
	*theStream << (SInt32) theMajorVersion;
	*theStream << "." << (SInt32) theMinorVersion;
	theStream->WriteCStringNoEnc("\r\t<DT>Language code: ");
	*theStream << (SInt32) theLanguage;
	theStream->WriteCStringNoEnc("\r\t<DT>Script code: ");
	*theStream << (SInt32) theScript;
	theStream->WriteCStringNoEnc("\r</DL>\r<P>");
	
	theSuiteCount = mAete->CountSuites();
	
	if (theSuiteCount > 0) {
		TArrayIterator<CAeteSuite*> iteraror( *mAete->GetSuites() );
		CAeteSuite *	theSuite;
		
		while (iteraror.Next(theSuite)) {
			theSuite->GetValues(theName, theDescr, theCode, theLevel, theVersion);
			
			// SUITE PREAMBULE	
			theStream->WriteCStringNoEnc("\r\r<hr>");
			theStream->WriteCStringNoEnc("<H1>Suite: ");
			*theStream << theName;
			theStream->WriteCStringNoEnc("</H1>\r<BLOCKQUOTE>\r<DL>\r\t<DT>Description: ");
			*theStream << theDescr ;			
			theStream->WriteCStringNoEnc("\r\t<DT>Suite ID: ");
			theStream->WriteOSType(theCode);
			theStream->WriteCStringNoEnc("\r\t<DT>Suite Level: ");
			*theStream << (SInt32) theLevel;
			theStream->WriteCStringNoEnc("\r\t<DT>Suite Version: ");
			*theStream << (SInt32) theVersion;
			theStream->WriteCStringNoEnc("\r</DL>\r</BLOCKQUOTE>\r<P>\r");
			
			// EVENTS	
			theEventCount = theSuite->CountEvents();
			if (theEventCount > 0) {
				TArrayIterator<CAeteEvent*> iterEv( *theSuite->GetEvents() );
				CAeteEvent *	theEvent;
				
				theStream->WriteCStringNoEnc("<H2>Array of Events</H2>\r<OL>\r\r");
				
				while (iterEv.Next(theEvent)) {
					
					theEvent->GetValues(theName, theDescr, theType, theCode, 
										theReplyType, replyDescr, replyFlags, 
										theDirectType, directDescr, directFlags);
					
					theStream->WriteCStringNoEnc("\t<LI>Event: ");
					
					*theStream << theName;
					theStream->WriteCStringNoEnc("\r\t\t<UL>\r\t\t\t<LI>Description: ");
					*theStream << theDescr;
					theStream->WriteCStringNoEnc("\r\t\t\t<LI>Event Class: ");
					theStream->WriteOSType(theType);
					theStream->WriteCStringNoEnc("\r\t\t\t<LI>Event ID: ");
					theStream->WriteOSType(theCode);
					theStream->WriteCStringNoEnc("\r\t\t\t<LI>Reply's Type: ");
					theStream->WriteOSType(theReplyType);
					
					theStream->WriteCStringNoEnc("\r\t\t\t<LI>Reply's Description: ");
					*theStream << replyDescr;
					
					// 	Reply's flags
					theStream->WriteCStringNoEnc("\r\t\t\t<LI>Reply is optional: ");
					*theStream << (SInt32) ( (replyFlags & (1 << kAEUTOptional)) > 0);
					theStream->WriteCStringNoEnc("\r\t\t\t<LI>Reply is list: ");
					*theStream << (SInt32) ( (replyFlags & (1 << kAEUTlistOfItems)) > 0);
					theStream->WriteCStringNoEnc("\r\t\t\t<LI>Reply is enumerated: ");
					*theStream << (SInt32) ( (replyFlags & (1 << kAEUTEnumerated)) > 0);
					
					theStream->WriteCStringNoEnc("\r\t\t\t<LI>Direct Param Type: ");
					theStream->WriteOSType(theDirectType);
					theStream->WriteCStringNoEnc("\r\t\t\t<LI>Direct Param Description: ");
					*theStream << directDescr;
					
					// 	Direct parameter's flags
					theStream->WriteCStringNoEnc("\r\t\t\t<LI>Direct Param is optional: ");
					*theStream << (SInt32) ( (directFlags & (1 << kAEUTOptional)) > 0);
					theStream->WriteCStringNoEnc("\r\t\t\t<LI>Direct Param is list: ");
					*theStream << (SInt32) ( (directFlags & (1 << kAEUTlistOfItems)) > 0);
					theStream->WriteCStringNoEnc("\r\t\t\t<LI>Direct Param is enumerated: ");
					*theStream << (SInt32) ( (directFlags & (1 << kAEUTEnumerated)) > 0);
					theStream->WriteCStringNoEnc("\r\t\t\t<LI>Changes state: ");
					*theStream << (SInt32) ( (directFlags & (1 << kAEUTChangesState)) > 0);						
					
					// ADDITIONAL PARAMETERS	
					theCount = theEvent->CountParameters();
					
					if (theCount) {
						theStream->WriteCStringNoEnc("\r\t\t\t<LI>Array of Other Parameters\r\t\t\t\t<OL>\r");
						TArrayIterator<CAeteParameter*> iterator( *theEvent->GetParameters() );
						CAeteParameter *	theParameter;
						
						while (iterator.Next(theParameter)) {
							theParameter->GetValues(theName, theCode, theType, theDescr, theFlags);
							
							theStream->WriteCStringNoEnc("\r\t\t\t\t\t<LI>Parameter: ");
							*theStream << theName;
							theStream->WriteCStringNoEnc("\r\t\t\t\t\t\t<UL>\r\t\t\t\t\t\t\t<LI>ID: ");
							theStream->WriteOSType(theCode);
							theStream->WriteCStringNoEnc("\r\t\t\t\t\t\t\t<LI>Type: ");
							theStream->WriteOSType(theType);
							theStream->WriteCStringNoEnc("\r\t\t\t\t\t\t\t<LI>Description: ");
							*theStream << theDescr;
							
							// 	Parameter's flags
							theStream->WriteCStringNoEnc("\r\t\t\t\t\t\t\t<LI>Param is optional: ");
							*theStream << (SInt32) ( (theFlags & (1 << kAEUTOptional)) > 0);
							theStream->WriteCStringNoEnc("\r\t\t\t\t\t\t\t<LI>Param is list: ");
							*theStream << (SInt32) ( (theFlags & (1 << kAEUTlistOfItems)) > 0);
							theStream->WriteCStringNoEnc("\r\t\t\t\t\t\t\t<LI>Param is enumerated: ");
							*theStream << (SInt32) ( (theFlags & (1 << kAEUTEnumerated)) > 0);
							theStream->WriteCStringNoEnc("\r\t\t\t\t\t\t\t<LI>Plural: ");
							*theStream << (SInt32) ( (theFlags & (1 << kAEUTPlural)) > 0);
							
							theStream->WriteCStringNoEnc("\r\t\t\t\t\t\t</UL>\r\r");
						}
						theStream->WriteCStringNoEnc("\r\t\t\t\t</OL>\r");
					}
					theStream->WriteCStringNoEnc("\r\t\t</UL>\r");
				}
				theStream->WriteCStringNoEnc("\r</OL>\r\r");
			}
			
			// CLASSES
			theClassCount = theSuite->CountClasses();
			if (theClassCount > 0) {
				TArrayIterator<CAeteClass*> iterCl( *theSuite->GetClasses() );
				CAeteClass *	theClass;
				
				theStream->WriteCStringNoEnc("<H2>Array of Classes</H2>\r<OL>\r");
				
				while (iterCl.Next(theClass)) {
					theClass->GetValues(theName, theCode, theDescr);
					
					theStream->WriteCStringNoEnc("\r\t<LI>Class: ");
					*theStream << theName;
					theStream->WriteCStringNoEnc("\r\t\t<UL>\r\t\t\t<LI>ID: ");
					theStream->WriteOSType(theCode);
					theStream->WriteCStringNoEnc("\r\t\t\t<LI>Description: ");
					*theStream << theDescr ;					
					
					// CLASS PROPERTIES
					theCount = theClass->CountProperties();
					if (theCount) {
						TArrayIterator<CAeteProperty*> iterProp( *theClass->GetProperties() );
						CAeteProperty *	theProperty;
						
						theStream->WriteCStringNoEnc("\r\t\t\t<LI>Array of Properties\r\t\t\t\t<OL>\r\r");
						
						while (iterProp.Next(theProperty)) {
							theProperty->GetValues(theName, theCode, theType, theDescr, theFlags);
							
							theStream->WriteCStringNoEnc("\r\t\t\t\t\t<LI>Property: ");
							*theStream << theName;
							theStream->WriteCStringNoEnc("\r\t\t\t\t\t\t<UL>\r\t\t\t\t\t\t\t<LI>Property ID: ");
							theStream->WriteOSType(theCode);
							theStream->WriteCStringNoEnc("\r\t\t\t\t\t\t\t<LI>Property Class: ");
							theStream->WriteOSType(theType);
							theStream->WriteCStringNoEnc("\r\t\t\t\t\t\t\t<LI>Description: ");
							*theStream << theDescr;
							
							// 	Property's flags
							theStream->WriteCStringNoEnc("\r\t\t\t\t\t\t\t<LI>Property Is List: ");
							*theStream << (SInt32) ( (theFlags & (1 << kAEUTlistOfItems)) > 0);
							theStream->WriteCStringNoEnc("\r\t\t\t\t\t\t\t<LI>Property Is Enumerated: ");
							*theStream << (SInt32) ( (theFlags & (1 << kAEUTEnumerated)) > 0);
							theStream->WriteCStringNoEnc("\r\t\t\t\t\t\t\t<LI>Is read-write property: ");
							*theStream << (SInt32) ( (theFlags & (1 << kAEUTReadWrite)) > 0);
							theStream->WriteCStringNoEnc("\r\t\t\t\t\t\t\t<LI>Plural: ");
							*theStream << (SInt32) ( (theFlags & (1 << kAEUTPlural)) > 0);
							
							theStream->WriteCStringNoEnc("\r\t\t\t\t\t\t</UL>\r");
						}
						theStream->WriteCStringNoEnc("\r\t\t\t\t</OL>\r\r");
					} 
					
					// CLASS ELEMENTS
					theCount = theClass->CountElements();
					if (theCount) {
						TArrayIterator<CAeteElement*> iterElem( *theClass->GetElements() );
						CAeteElement *	theElement;
						
						theStream->WriteCStringNoEnc("\r\t\t\t<LI>Array of Elements\r\t\t\t\t<OL>\r\r");
						
						while (iterElem.Next(theElement)) {
							theType = theElement->GetID();				
							
							theStream->WriteCStringNoEnc("\r\t\t\t\t\t<LI>Class Element ID: ");
							theStream->WriteOSType(theType);
							
							// KEY FORMS
							theSubCount = theElement->CountKeyForms();
							if (theSubCount) {
								TArrayIterator<OSType> iterator( *theElement->GetKeyForms() );
								OSType 	theKeyForm;
								theStream->WriteCStringNoEnc("\r\t\t\t\t\t\t<OL>");
								
								while (iterator.Next(theKeyForm)) {
									theStream->WriteCStringNoEnc("\r\t\t\t\t\t\t\t<LI>Key Form ID: ");
									theStream->WriteOSType(theKeyForm);
								}
								theStream->WriteCStringNoEnc("\r\t\t\t\t\t\t</OL>\r\r");
							} 
						}
						theStream->WriteCStringNoEnc("\r\t\t\t\t</OL>\r\r");
					}
					theStream->WriteCStringNoEnc("\r\t\t</UL>\r\r");
				}
				theStream->WriteCStringNoEnc("</OL>\r\r");
			} 
			
			// COMPARISON OPERATORS
			theCompOpCount = theSuite->CountCompOps();
			if (theCompOpCount >0) {
				TArrayIterator<CAeteCompOp*> iterCo( *theSuite->GetCompOps() );
				CAeteCompOp *	theCompOp;
				
				theStream->WriteCStringNoEnc("<H2>Array of Comparison Operators</H2>\r<OL>\r");
				
				while (iterCo.Next(theCompOp)) {
					theCompOp->GetValues(theName, theCode, theDescr);
					
					theStream->WriteCStringNoEnc("\r\t<LI>Comparison Operator: ");
					*theStream << theName;
					theStream->WriteCStringNoEnc("\r\t\t<UL>\r\t\t\t<LI>ID: ");
					theStream->WriteOSType(theCode);
					theStream->WriteCStringNoEnc("\r\t\t\t<LI>Description: ");
					*theStream << theDescr;
					theStream->WriteCStringNoEnc("\r\t\t</UL>\r");
				}
				theStream->WriteCStringNoEnc("</OL>\r\r");
			} 		
			
			// ENUMERATIONS
			theEnumCount = theSuite->CountEnumerations();
			if (theEnumCount >0) {
				TArrayIterator<CAeteEnumeration*> iterEn( *theSuite->GetEnumerations() );
				CAeteEnumeration *	theEnumeration;
				
				theStream->WriteCStringNoEnc("<H2>Array of Enumerations</H2>\r<OL>\r");
				
				while (iterEn.Next(theEnumeration)) {
					theCode = theEnumeration->GetEnumerationID();
					
					theStream->WriteCStringNoEnc("\r\t<LI>Enumeration ID: ");
					theStream->WriteOSType(theCode);
					
					// ENUMERATORS
					theCount = theEnumeration->CountEnumerators();
					if (theCount) {
						TArrayIterator<AeteEnumerator> iterator( *theEnumeration->GetEnumerators() );
						AeteEnumerator 	numerator;
						
						theStream->WriteCStringNoEnc("\r\t\t<OL>\r");
						
						while (iterator.Next(numerator)) {
							theStream->WriteCStringNoEnc("\r\t\t\t<LI>Name: ");
							*theStream << numerator.name;
							theStream->WriteCStringNoEnc("\r\t\t\t\t<UL>\r\t\t\t\t\t<LI>ID: ");
							theStream->WriteOSType(numerator.type);
							theStream->WriteCStringNoEnc("\r\t\t\t\t\t<LI>Description: ");
							*theStream << numerator.description;
							theStream->WriteCStringNoEnc("\r\t\t\t\t</UL>\r");
						}
						theStream->WriteCStringNoEnc("\r\t\t</OL>\r\r");
					} 
				}
				theStream->WriteCStringNoEnc("\r\t\t</OL>\r\r");
			} 		
		}
		theStream->WriteCStringNoEnc("</OL>\r\r");
	} 
	theStream->WriteCStringNoEnc("\r\r</BODY>\r</HTML>");
}


// ---------------------------------------------------------------------------------
//  WriteOutText
// ---------------------------------------------------------------------------------

void
StAeteExporter::WriteOutText()
{
	UInt16		index, 
				theCount,
				theSubCount,
				theSuiteCount,
				theEventCount,
				theClassCount,
				theCompOpCount,
				theEnumCount;
	UInt16		theLevel, theVersion;
	UInt16 		theFlags, replyFlags, directFlags;
	OSType		theType, theCode, theReplyType, theDirectType;
	Str255 		theName, theDescr, replyDescr, directDescr;
	UInt8		theMajorVersion, theMinorVersion;
	SInt16		theLanguage, theScript;

	if (mRezObj != nil) {
		LString::CopyPStr(*(mRezObj->GetName()), theName);
		*mFileStream << "Aete resource " << (SInt32) mRezObj->GetID() << " - " << theName << "\r";		
	} 
	
	mAete->GetValues(theMajorVersion, theMinorVersion, theLanguage, theScript);
	*mFileStream << "Version: " << (SInt32) theMajorVersion;
	*mFileStream << (UInt8) '.' << (SInt32) theMinorVersion << "\r";
	*mFileStream << "Language code: " << (SInt32) theLanguage << "\r";
	*mFileStream << "Script code: " << (SInt32) theScript << "\r";
	
	theSuiteCount = mAete->CountSuites();
	*mFileStream << (SInt32) theSuiteCount;
	*mFileStream << " suites";

	if (theSuiteCount > 0) {
		TArrayIterator<CAeteSuite*> iteraror( *mAete->GetSuites() );
		CAeteSuite *	theSuite;
		
		while (iteraror.Next(theSuite)) {
			theSuite->GetValues(theName, theDescr, theCode, theLevel, theVersion);
			
			// SUITE PREAMBULE	
			*mFileStream << "\r\r\r";
			*mFileStream << theName;
			
			*mFileStream << ": ";
			*mFileStream << theDescr;
			
			*mFileStream << "\rSuite ID: '";
			mFileStream->WriteOSType(theCode);
			*mFileStream << "'\r";
			
			*mFileStream << "Suite level: ";
			*mFileStream << (SInt32) theLevel;
			*mFileStream << "\r";
			
			*mFileStream << "Suite version: ";
			*mFileStream << (SInt32) theVersion;
			*mFileStream << "\r";
			

			// EVENTS	
			theEventCount = theSuite->CountEvents();
			*mFileStream << "\r\r";
			*mFileStream << (SInt32) theEventCount;
			*mFileStream << " events";

			if (theEventCount > 0) {
				TArrayIterator<CAeteEvent*> iterEv( *theSuite->GetEvents() );
				CAeteEvent *	theEvent;
				
				while (iterEv.Next(theEvent)) {
					
					theEvent->GetValues(theName, theDescr, theType, theCode, 
										theReplyType, replyDescr, replyFlags, 
										theDirectType, directDescr, directFlags);
					
					*mFileStream << "\r\rEvent: ";
					*mFileStream << theName;
					
					*mFileStream << "\r    Description: ";
					*mFileStream << theDescr;
					
					*mFileStream << "\r    Event class: '";
					mFileStream->WriteOSType(theType);
					*mFileStream << "'\r";
					
					*mFileStream << "    Event ID: '";
					mFileStream->WriteOSType(theCode);
					*mFileStream << "'\r";
					
					*mFileStream << "    Type of reply's direct parameter: '";
					mFileStream->WriteOSType(theReplyType);
					*mFileStream << "'\r";
					
					*mFileStream << "    Description of reply's direct parameter: ";
					*mFileStream << replyDescr;
					
					// 	Reply's flags
					if ( (replyFlags & (1 << kAEUTOptional)) > 0) {
						*mFileStream << "\r    Reply is optional. ";
					} else {
						*mFileStream << "\r    Reply is required. ";
					}
					if ( (replyFlags & (1 << kAEUTlistOfItems)) > 0) {
						*mFileStream << "It is a list, ";
					} else {
						*mFileStream << "It is a single item, ";
					}
					if ( (replyFlags & (1 << kAEUTEnumerated)) > 0) {
						*mFileStream << "enumerated.";
					} else {
						*mFileStream << "not enumerated.";
					}
					
					*mFileStream << "\r    Direct parameter's type: '";
					mFileStream->WriteOSType(theDirectType);
					*mFileStream << "'\r";
					
					*mFileStream << "    Direct parameter's description: ";
					*mFileStream << directDescr;
					
					// 	Direct parameter's flags
					if ( (directFlags & (1 << kAEUTOptional)) > 0) {
						*mFileStream << "\r    Direct parameter is optional. ";
					} else {
						*mFileStream << "\r    Direct parameter is required. ";
					}
					if ( (directFlags & (1 << kAEUTlistOfItems)) > 0) {
						*mFileStream << "It is a list, ";
					} else {
						*mFileStream << "It is a single item, ";
					}
					if ( (directFlags & (1 << kAEUTEnumerated)) > 0) {
						*mFileStream << "enumerated.";
					} else {
						*mFileStream << "not enumerated.";
					}
					if ( (directFlags & (1 << kAEUTChangesState)) > 0) {
						*mFileStream << "\r    It changes the server's state.";
					} else {
						*mFileStream << "\r    It does not change the server's state.";
					}
					
					// ADDITIONAL PARAMETERS	
					theCount = theEvent->CountParameters();
					if (theCount) {
						TArrayIterator<CAeteParameter*> iterator( *theEvent->GetParameters() );
						CAeteParameter *	theParameter;
						
						*mFileStream << "\r\r  ";
						*mFileStream << (SInt32) theCount;
						*mFileStream << " additional parameters";
						index = 0;
						
						while (iterator.Next(theParameter)) {
							theParameter->GetValues(theName, theCode, theType, theDescr, theFlags);
							
							*mFileStream << "\r    Parameter ";
							*mFileStream << (SInt32) ++index;
							*mFileStream << ": ";
							*mFileStream << theName;
							
							*mFileStream << "\r        ID: '";
							mFileStream->WriteOSType(theCode);
							*mFileStream << "'\r";
							
							*mFileStream << "        Type: '";
							mFileStream->WriteOSType(theType);
							*mFileStream << "'\r";
							
							*mFileStream << "        Description: ";
							*mFileStream << theDescr;
							
							// 	Parameter's flags
							if ( (theFlags & (1 << kAEUTOptional)) > 0) {
								*mFileStream << "\r        Parameter is optional. ";
							} else {
								*mFileStream << "\r        Parameter is required. ";
							}
							if ( (theFlags & (1 << kAEUTlistOfItems)) > 0) {
								*mFileStream << "It is a list, ";
							} else {
								*mFileStream << "It is a single item, ";
							}
							if ( (theFlags & (1 << kAEUTEnumerated)) > 0) {
								*mFileStream << "enumerated,";
							} else {
								*mFileStream << "not enumerated,";
							}
							if ( (theFlags & (1 << kAEUTPlural)) > 0) {
								*mFileStream << " plural.\r";
							} else {
								*mFileStream << " singular.\r";
							}
						
						}
					} else {
						*mFileStream << "\rNo additional parameters\r";
					}
				}
			}
			
			// CLASSES
			theClassCount = theSuite->CountClasses();
			*mFileStream << "\r\r";
			*mFileStream << (SInt32) theClassCount;
			*mFileStream << " classes";

			if (theClassCount > 0) {
				TArrayIterator<CAeteClass*> iterCl( *theSuite->GetClasses() );
				CAeteClass *	theClass;
				
				while (iterCl.Next(theClass)) {
					theClass->GetValues(theName, theCode, theDescr);
					
					*mFileStream << "\r\rClass: ";
					*mFileStream << theName;
					
					*mFileStream << "\r    Class ID: '";
					mFileStream->WriteOSType(theCode);
					*mFileStream << "'\r";
					
					*mFileStream << "\r    Class description: ";
					*mFileStream << theDescr;
					
					
					// CLASS PROPERTIES
					theCount = theClass->CountProperties();
					if (theCount) {
						TArrayIterator<CAeteProperty*> iterProp( *theClass->GetProperties() );
						CAeteProperty *	theProperty;
						
						*mFileStream << "\r    * ";
						*mFileStream << (SInt32) theCount;
						*mFileStream << " class properties\r";
						index = 0;

						while (iterProp.Next(theProperty)) {
							theProperty->GetValues(theName, theCode, theType, theDescr, theFlags);
							
							*mFileStream << "      (";
							*mFileStream << (SInt32) ++index;
							*mFileStream << ") ";
							*mFileStream << theName;
							
							*mFileStream << "\r        Property ID: '";
							mFileStream->WriteOSType(theCode);
							*mFileStream << "'\r";
							
							*mFileStream << "        Property class: '";
							mFileStream->WriteOSType(theType);
							*mFileStream << "'\r";
							
							*mFileStream << "        Property description: ";
							*mFileStream << theDescr;
							
							// 	Property's flags
							if ( (theFlags & (1 << kAEUTlistOfItems)) > 0) {
								*mFileStream << "\r        It is a list, ";
							} else {
								*mFileStream << "\r        It is a single item, ";
							}
							if ( (theFlags & (1 << kAEUTEnumerated)) > 0) {
								*mFileStream << "enumerated.";
							} else {
								*mFileStream << "not enumerated.";
							}
							if ( (theFlags & (1 << kAEUTReadWrite)) > 0) {
								*mFileStream << " [r/w]";
							} else {
								*mFileStream << " [r/o]";
							}
							if ( (theFlags & (1 << kAEUTPlural)) > 0) {
								*mFileStream << " plural.\r";
							} else {
								*mFileStream << " singular.\r";
							}
							*mFileStream << "\r";
						}
					} else {
						*mFileStream << "\rNo class properties\r";
					}
					
					// CLASS ELEMENTS
					theCount = theClass->CountElements();
					if (theCount) {
						TArrayIterator<CAeteElement*> iterElem( *theClass->GetElements() );
						CAeteElement *	theElement;
						
						*mFileStream << "\r    * ";
						*mFileStream << (SInt32) theCount;
						*mFileStream << " class elements\r";

						while (iterElem.Next(theElement)) {
							theType = theElement->GetID();				
							
							*mFileStream << "        Class element ID: '";
							mFileStream->WriteOSType(theType);
							*mFileStream << "'\r";
							
							// KEY FORMS
							theSubCount = theElement->CountKeyForms();
							if (theSubCount) {
								TArrayIterator<OSType> iterator( *theElement->GetKeyForms() );
								OSType 	theKeyForm;
								
								*mFileStream << "        ";
								*mFileStream << (SInt32) theSubCount;
								*mFileStream << " key forms:\r";
								index = 0;
								
								while (iterator.Next(theKeyForm)) {
									*mFileStream << "             (";
									*mFileStream << (SInt32) ++index;
									*mFileStream << "); '";
									mFileStream->WriteOSType(theKeyForm);
									*mFileStream << "'\r";
								}
							}  else {
								*mFileStream << "\rNo key forms\r";
							}
						}
					} else {
						*mFileStream << "\rNo class elements\r";
					}
				}
			} 
			
			// COMPARISON OPERATORS
			theCompOpCount = theSuite->CountCompOps();
			*mFileStream << "\r\r";
			*mFileStream << (SInt32) theCompOpCount;
			*mFileStream << " comparison operators";

			if (theCompOpCount >0) {
				TArrayIterator<CAeteCompOp*> iterCo( *theSuite->GetCompOps() );
				CAeteCompOp *	theCompOp;
							
				while (iterCo.Next(theCompOp)) {
					theCompOp->GetValues(theName, theCode, theDescr);
					
					*mFileStream << "\r\rComparison operator: ";
					*mFileStream << theName;
					
					*mFileStream << "\r    ID: '";
					mFileStream->WriteOSType(theCode);
					*mFileStream << "'\r";
					
					*mFileStream << "    Description: ";
					*mFileStream << theDescr;
				}
			} 		
			
			// ENUMERATIONS
			theEnumCount = theSuite->CountEnumerations();
			*mFileStream << "\r\r";
			*mFileStream << (SInt32) theEnumCount;
			*mFileStream << " enumerations";

			if (theEnumCount >0) {
				TArrayIterator<CAeteEnumeration*> iterEn( *theSuite->GetEnumerations() );
				CAeteEnumeration *	theEnumeration;
				
				while (iterEn.Next(theEnumeration)) {
					theCode = theEnumeration->GetEnumerationID();
					
					*mFileStream << "\r\rEnumeration ID: '";
					mFileStream->WriteOSType(theCode);
					*mFileStream << "'\r";
					
					// ENUMERATORS
					theCount = theEnumeration->CountEnumerators();
					if (theCount) {
						TArrayIterator<AeteEnumerator> iterator( *theEnumeration->GetEnumerators() );
						AeteEnumerator 	numerator;
						
						*mFileStream << "    ";
						*mFileStream << (SInt32) theCount;
						*mFileStream << " enumerators:";
						index = 0;
						
						while (iterator.Next(numerator)) {
							*mFileStream << "\r      ";
							*mFileStream << (SInt32) ++index;
							*mFileStream << "- ";
							*mFileStream << numerator.name;
							
							*mFileStream << "\r          ID: '";
							mFileStream->WriteOSType(numerator.type);
							*mFileStream << "'\r";
							
							*mFileStream << "          Description: ";
							*mFileStream << numerator.description;
						}
					} else {
						*mFileStream << "\rNo enumerators\r";
					}
				}
			} 		
		}
	} 
}


#pragma mark -

// ---------------------------------------------------------------------------------
//  ConvertToSdefForm
// ---------------------------------------------------------------------------------
// This function attempts a very rudimentary mapping from existing keyform 
// codes to the accessor types supported by sdef.
// 
// According to "man sdef":
//      accessor	  Accessors define which access forms an element supports.
// 		  There are six forms:
// 		  ATTRIBUTES
// 		  style		index | name | id | range | relative | test
// 		  
// They correspond to (cf AEObjects.h): 
// 				formAbsolutePosition	'indx'
// 				formName				'name'
// 				formRange				'rang'
// 				formRelativePosition	'rele'
// 				formTest				'test'
// 				formUniqueID			'ID  '

void
StAeteExporter::ConvertToSdefForm(CXMLFileStream * inFileStream, OSType inType)
{
	switch (inType) {
		case formUniqueID:
		*inFileStream << "id";
		break;
		
		case formAbsolutePosition:
		*inFileStream << "index";
		break;
		
		case formName:
		*inFileStream << "name";
		break;
		
		case formRange:
		*inFileStream << "range";
		break;
		
		case formRelativePosition:
		*inFileStream << "relative";
		break;
		
		case formTest:
		*inFileStream << "test";
		break;
		
		default:
		// If none of the above, write it verbatim
		mFileStream->WriteOSType(inType);
		break;
	}
}


// ---------------------------------------------------------------------------------
//  ConvertToSdefType
// ---------------------------------------------------------------------------------
// This function attempts a very rudimentary mapping from existing type 
// codes to the types supported by sdef.
// 
// According to "man sdef":
// 		type	 The type of an element, property, or parameter.  The value
// 				 must be one of the primitive types `any', `string',
// 				 `integer', `real', `boolean', `object', `location',
// 				 `record', `file', `point', `rectangle', or `type', the name
// 				 of a type or class defined elsewhere in the sdef, `list of'
// 				 followed by a type (e.g., `list of integer'), or a list of
// 				 alternative types separated by vertical bars (e.g., `integer
// 				 | string').
// 				 
// 	See enums of typeXXX constants in AERegistry.h (typeInsertionLoc etc.).
// 	Not sure what to map to "real".

void
StAeteExporter::ConvertToSdefType(CXMLFileStream * inFileStream, OSType inType, UInt16 inFlags)
{
	if (inFlags & (1 << kAEUTlistOfItems)) {
		*inFileStream << "list of ";
	} 

	if (inFlags & (1 << kAEUTEnumerated)) {
		Str255 enumName;
		if ( FindEnumNameForType(inType, enumName) ) {
			*mFileStream << enumName;
			return;
		} 
	} 

	switch (inType) {
		case '****':
		*inFileStream << "any";
		break;
		
		case 'bool':
		*inFileStream << "boolean";
		break;
		
		case 'insl':
		*inFileStream << "location";
		break;
		
		case 'long':
		*inFileStream << "integer";
		break;
		
		case 'obj ':
		*inFileStream << "object";
		break;
		
		case 'QDpt':
		*inFileStream << "point";
		break;
		
		case 'qdrt':
		case 'crec':
		*inFileStream << "rectangle";
		break;
		
		case 'reco':
		*inFileStream << "record";
		break;
		
		case 'type':
		*inFileStream << "type";
		break;
		
		case 'TEXT':
		case 'tTXT':
		case 'itxt':
		*inFileStream << "string";
		break;
		
// 		case 'alis':
// 		case 'fsrf':
// 		case 'fss ':
		case 'file':
		case 'kfil':
		*inFileStream << "file";
		break;
		
		default:
		// If none of the above, we should look for the name of a class.
		// If this fails, write verbatim.
		Str255 className;
		if ( FindClassNameForType(inType, className) ) {
			*mFileStream << className;
		} else {
			mFileStream->WriteOSType(inType);
		}
		break;
	}
}


// ---------------------------------------------------------------------------------
//  FindClassNameForType
// ---------------------------------------------------------------------------------

Boolean
StAeteExporter::FindClassNameForType(OSType inType, Str255 & outName)
{
	Boolean found = false;
	UInt16	suiteCount, classCount;
	OSType	theCode;
	Str255 	theDescr;

	suiteCount = mAete->CountSuites();
	
	if (suiteCount > 0) {
		TArrayIterator<CAeteSuite*> iteraror( *mAete->GetSuites() );
		CAeteSuite *	theSuite;
		
		while (iteraror.Next(theSuite)) {
			classCount = theSuite->CountClasses();
			
			if (classCount > 0) {
				TArrayIterator<CAeteClass*> iterCl( *theSuite->GetClasses() );
				CAeteClass *	theClass;
				
				while (iterCl.Next(theClass)) {
					theClass->GetValues(outName, theCode, theDescr);
					if (theCode == inType) {
// 						LString::CopyPStr(theName, outName);
						return true;
					} 
				}
			}
		}
	}
	
	return found;
}
 

// ---------------------------------------------------------------------------------
//  FindEnumNameForType
// ---------------------------------------------------------------------------------

Boolean
StAeteExporter::FindEnumNameForType(OSType inType, Str255 & outName)
{
	Boolean found = false;
	UInt16	suiteCount, enumCount;

	suiteCount = mAete->CountSuites();
	
	if (suiteCount > 0) {
		TArrayIterator<CAeteSuite*> iteraror( *mAete->GetSuites() );
		CAeteSuite *	theSuite;
		
		while (iteraror.Next(theSuite)) {
			enumCount = theSuite->CountEnumerations();
			if (enumCount >0) {
				TArrayIterator<CAeteEnumeration*> iterEn( *theSuite->GetEnumerations() );
				CAeteEnumeration *	theEnum;
				
				while (iterEn.Next(theEnum)) {
					if (theEnum->GetEnumerationID() == inType) {
						UMiscUtils::OSTypeToPString(inType, outName);
						return true;
					} 
				}
			}
		}
	}
	
	return found;
}



#pragma mark -

// ====================
// Class StAeteImporter
// ====================

// ---------------------------------------------------------------------------
//   StAeteImporter							Constructor		 	 [public]
// ---------------------------------------------------------------------------

StAeteImporter::StAeteImporter(CAete *	inAete,
								FSSpec 	inFSSpec )
{	
	mAete = inAete;
	mFileSpec = inFSSpec;
}


// ---------------------------------------------------------------------------
//     ~StAeteImporter							Destructor			  [public]
// ---------------------------------------------------------------------------

StAeteImporter::~StAeteImporter()
{}


// ---------------------------------------------------------------------------------
//  ReadXml															 [public]
// ---------------------------------------------------------------------------------

OSErr
StAeteImporter::ReadXml()
{
	OSErr			error;
	CFURLRef		theUrl;
	FSRef   	 	theFSRef;
	CFXMLTreeRef    cfXMLTree;
	CFDataRef       xmlData;
	
	error = FSpMakeFSRef( &mFileSpec, &theFSRef );
	theUrl = CFURLCreateFromFSRef(kCFAllocatorDefault, &theFSRef);
	
	// Load the XML data using its URL.
	if (theUrl) {
		CFURLCreateDataAndPropertiesFromResource(kCFAllocatorDefault, theUrl, 
												 &xmlData, NULL, NULL, NULL);
		// Parse the XML and get the CFXMLTree. 
		if (xmlData) {
			cfXMLTree = CFXMLTreeCreateFromData(kCFAllocatorDefault, xmlData, theUrl, 
												kCFXMLParserSkipWhitespace, kCFXMLNodeCurrentVersion);

			if (cfXMLTree != NULL) {
				error = ParseTree(cfXMLTree);
			} else {
				error = err_ImportCantBuildTree;
			}
		} else {
			error = err_ImportCantGetXmlData;
		}
	} 
	
	return error;
}


// ---------------------------------------------------------------------------------
//  ParseTree														 [private]
// ---------------------------------------------------------------------------------
//  CFShow(CFXMLNodeGetString(xmlNode));
// 			EXTERN_API_C( CFTreeRef )
// 			CFTreeFindRoot(CFTreeRef tree);

OSErr
StAeteImporter::ParseTree(CFXMLTreeRef inXMLTree)
{
	OSErr			error = noErr;
	CFXMLTreeRef    xmlTreeNode;
	CFXMLNodeRef    xmlNode;
	int             childCount;
	int             index;
	
	// Get a count of the top level node's children.
	childCount = CFTreeGetChildCount(inXMLTree);
	
	// Print the data string for each top-level node.
	for (index = 0; index < childCount; index++) {
		xmlTreeNode = CFTreeGetChildAtIndex(inXMLTree, index);
		if (xmlTreeNode) {
			xmlNode = CFXMLTreeGetNode(xmlTreeNode);
			if (xmlNode) {
				if (CFXMLNodeGetTypeCode(xmlNode) == kCFXMLNodeTypeElement
					&&  ! CFStringCompare( CFXMLNodeGetString(xmlNode), CFSTR("AeteResource"), 0) ) {
						
					error = mAete->GetDataFromXml(xmlTreeNode);
				} 
			}  else {
				error = err_ImportCantGetTopAeteNode;
			}
		} 
	}	
	return error;
}
 

PP_End_Namespace_PowerPlant

