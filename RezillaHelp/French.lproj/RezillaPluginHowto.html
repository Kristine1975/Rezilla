<HTML>
<HEAD>
<TITLE>RezillaPluginHowto</TITLE>
<META HTTP-EQUIV="content-type" CONTENT="text/html;charset=macintosh">
<META NAME="generator" CONTENT="Aida Mode">
<META HTTP-EQUIV="Content-Language" CONTENT="fr-FR">
<META NAME="keywords" CONTENT="ressource, plugin">
</HEAD>
<BODY>
<P><P><IMG SRC="../Images/rezilla_logo.gif" ALT="Rezilla logo" ALIGN=bottom></P><P><HR><BLOCKQUOTE><P><I> 
Ce document est un tutoriel consacré à l'architecture de plugins de
l'éditeur de ressources <B>Rezilla</B> pour Mac OS X. Il explique, au moyen
d'exemples, comment écrire de nouveaux plugins afin d'ajouter des éditeurs
externes à Rezilla.
Le présent document correspond à la version 
<B>1.1</B> de Rezilla.
</I></P></BLOCKQUOTE><HR><P><UL>
<LI><A HREF="#M1">Écrire un Plugin pour Rezilla</A>
<UL><LI><A HREF="#M2">Le modèle des plugins</A></UL>
<UL><LI><A HREF="#M3">Anatomie du plugin</A></UL>
<UL><LI><A HREF="#M4">Les UUIDs de plugin</A></UL>
<UL><UL><LI><A HREF="#M5">Les UUIDs de Rezilla</A></UL></UL>
<UL><UL><LI><A HREF="#M6">Les UUIDs des fabriques</A></UL></UL>
<UL><UL><LI><A HREF="#M7">Créer un UUID</A></UL></UL>
<UL><LI><A HREF="#M8">Liste de propriétés du plugin</A></UL>
<UL><UL><LI><A HREF="#M9">Les clés du Système</A></UL></UL>
<UL><UL><LI><A HREF="#M10">Les clés de CFPlugin </A></UL></UL>
<UL><UL><LI><A HREF="#M11">Les clés de Rezilla</A></UL></UL>
<UL><LI><A HREF="#M12">L'interface du plugin</A></UL>
<UL><UL><LI><A HREF="#M13">La structure de l'interface</A></UL></UL>
<UL><UL><LI><A HREF="#M14">Interaction avec le plugin</A></UL></UL>
<UL><UL><LI><A HREF="#M15">Les requêtes du plugin</A></UL></UL>
<UL><UL><LI><A HREF="#M16">Les commandes supportées</A></UL></UL>
<UL><UL><LI><A HREF="#M17">Informations de l'hôte</A></UL></UL>
<UL><UL><LI><A HREF="#M18">Codes d'erreur</A></UL></UL>
<UL><LI><A HREF="#M19">Le plugin Sample</A></UL>
<UL><UL><LI><A HREF="#M20">Les fichiers source de Sample </A></UL></UL>
<UL><UL><LI><A HREF="#M21">L'UUID de Sample </A></UL></UL>
<UL><UL><LI><A HREF="#M22">La liste de propriétés de Sample</A></UL></UL>
<UL><UL><LI><A HREF="#M23">Le fichier de projet</A></UL></UL>
<UL><UL><LI><A HREF="#M24">Le code source </A></UL></UL>
<UL><UL><UL><LI><A HREF="#M25">Les structures de Sample </A></UL></UL></UL>
<UL><UL><UL><LI><A HREF="#M26">La fabrique Sample</A></UL></UL></UL>
<UL><UL><UL><LI><A HREF="#M27">Les fonctions COM </A></UL></UL></UL>
<UL><UL><UL><LI><A HREF="#M28">La transaction préliminaire</A></UL></UL></UL>
<UL><UL><UL><LI><A HREF="#M29">Les fonctions de l'interface</A></UL></UL></UL>
<UL><LI><A HREF="#M30">Référence des plugins</A></UL>
<UL><UL><LI><A HREF="#M31">Structures</A></UL></UL>
<UL><UL><UL><LI><A HREF="#M32">SPluginEditorInterface</A></UL></UL></UL>
<UL><UL><UL><LI><A HREF="#M33">RezPlugInfo</A></UL></UL></UL>
<UL><UL><UL><LI><A HREF="#M34">RezHostInfo</A></UL></UL></UL>
<UL><UL><LI><A HREF="#M35">Énumérations</A></UL></UL>
<UL><UL><UL><LI><A HREF="#M36">RezillaPluginFlags</A></UL></UL></UL>
<UL><UL><UL><LI><A HREF="#M37">RezillaPluginCmdIDs</A></UL></UL></UL>
<UL><UL><UL><LI><A HREF="#M38">RezillaPluginErrors</A></UL></UL></UL>
</UL><P><H2><A NAME="M1"></A>Écrire un Plugin pour Rezilla</H2><P>Cette section est destinée aux développeurs souhaitant écrire un plugin 
pour Rezilla. <P>Une architecture complète de plugins a été mise en place dans <B>Rezilla</B> à partir de la version 1.1. Elle s'appuie sur l'API CFPlugin définie
dans le <I>framework</I> CoreFoundation. Cette interface de programmation est
basée sur le modèle COM (<I>Component Object Model</I>) de Microsoft. Pour en
savoir plus sur le modèle CFPlugin et l'architecture COM, on pourra se
référer à la documentation d'Apple, en particulier:
<A HREF="http://developer.apple.com/documentation/CoreFoundation/Conceptual/CFPlugIns/index.html">http://developer.apple.com/documentation/CoreFoundation/Conceptual/CFPlugIns/index.html</A><P>Le péesent document explique comment écrire un plugin pour Rezilla, 
conformément à ce modèle. Il s'adresse aux développeurs souhaitant 
apporter de nouvelles fonctionalités à Rezilla et comporte les 
instructions générales ainsi que l'information technique nécessaires.<P><H3><A NAME="M2"></A>Le modèle des plugins</H3><P>Un plugin implémente une <I>interface</I> que l'on peut voir comme
l'incarnation d'un <I>service</I>. Selon la terminologie en vigueur, on
emploie le mot <I>type</I> pour désigner un service: le <I>type</I> d'un
plugin d'édition, dans le cas de Rezilla, est le fait d'éditer les données
d'une ressource particulière (le mot <I>type</I> ici peut prêter à
confusion et ne doit pas être confondu avec le type d'une ressource !).
Dans la version 1.1, Rezilla ne connaît que ce type de plugins: le service
d'édition. Dans l'avenir, Rezilla pourrait aussi introduire des plugins
permettant de définir des fenêtres de sélection de ressources (<I>resource
pickers</I>), par exemple, et cela conduirait à introduire un nouveau type
puisqu'il s'agit d'un service différent.<P>Il n'y a pas forcément une interface unique pour un type donné: il peut y
en avoir plusieurs. Par exemple, de futures versions de Rezilla, pourraient
modifier l'interface actuelle: cela se ferait par le biais d'une nouvelle
interface. Dans ce cas, un plugin se devrait d'implémenter à la fois
l'ancienne et la nouvelle interface et Rezilla pourrait déterminer, en
fonction du contexte, quelle interface il faut utiliser. La version 1.1 de
Rezilla ne définit qu'une interface pour le service d'édition. Une
interface peut être vue comme une liste de fonctions correspondant aux
diverses tâches à exécuter au cours de l'édition d'une ressource.<P><A NAME="plugbundle"></A>
<H3><A NAME="M3"></A>Anatomie du plugin</H3>
Techniquement un plugin est simplement une bibliothèque dynamique (<I>dynamic 
library</I>) qui est chargée par l'application principale dès que nécessaire. 
Sous OS X, cette bibliothèque se présente sous forme de ce que l'on appelle un
paquetage (<I>bundle</I>), c'est-à-dire une structure analogue à un répertoire
qui contient la bibliothèque elle-même et quelques fichiers complémentaires.<P>Pour en savoir plus sur les <I>paquetages</I> sous OS X, voir:
<A HREF="http://developer.apple.com/documentation/CoreFoundation/Conceptual/CFBundles/Concepts/about.html">http://developer.apple.com/documentation/CoreFoundation/Conceptual/CFBundles/Concepts/about.html</A><P>L'utilisation de cette architecture facilite considérablement, du point de 
vue de l'utilisateur, les tâches de maintenance relatives aux plugins,
comme l'ajout, la suppression, l'activation ou la désactivation.
Toutes ces actions peuvent être accomplies depuis le Finder de façon 
transparente (voir la section <I>Éditeurs Externes</I> dans l'aide de 
Rezilla). L'utilisateur n'a pas à connaître la localisation exacte des 
plugins à l'intérieur de l'application.<P>Voici, à titre d'exemple, la structure interne du plugin <B>RezImagePlugin</B>,
fourni avec la version 1.1 de Rezilla:
<P><IMG SRC="../Images/rzil_pluginanatomy.gif " ALT="Plugin anatomy" ALIGN=bottom></P><P>Ce plugin s'appelle <I>RezImagePlugin.plugin</I>. Il doit avoir une
extension <I>.plugin</I> afin que Rezilla puisse le trouver. Certains
éléments du sous-dossier <I>Contents</I> sont obligatoires, les autres
sont facultatifs. Les éléments obligatoires sont:
<UL>
	<LI> le fichier <I>Info.plist</I> qui est un fichier de liste de propriétés
contenant des informations sur le paquetage. Voir la
section <A HREF="#plugplist"><I>Liste de propriétés du plugin</I></A> 
ci-dessous.
	<LI> le sous-dossier <I>MacOS</I> qui comporte la bibliothèque dynamique 
elle-même
(<I>RezImagePlugin</I> dans l'exemple précédent).
</UL><P>Le sous-dossier <I>Resources</I> peut contenir des données supplémentaires. 
Dans l'exemple précédent, on y trouve:
<UL>
	<LI> un fichier de ressources appelé <I>RezImagePlugin.rsrc</I> qui définit 
des 
ressources utilisées par le plugin. Le nom du fichier de ressources est le 
nom de l'exécutable (la bibliothèque située dans le sous-dossier <I>MacOS</I> 
du plugin) suivi d'une extension <TT>.rsrc</TT>.<P>	<LI> les dossiers de localisation (<I>English.lproj, French.lproj</I>)
avec les données localisées pour un langage particulier. Dans le présent
exemple, deux fichiers contiennent des chaînes localisées utilisées par le
plugin. D'autres langages peuvent bien entendu être ajoutés.<P></UL><P><A NAME="pluguuids"></A>
<H3><A NAME="M4"></A>Les UUIDs de plugin</H3><P>Divers éléments du modèle de plugins défini (l'API CFPlugin dans les Core
Foundations de OS X) sont identifiés au moyen d'un UUID (<I>Universally
Unique Identifier</I>, identificateur universellement unique). Certains
UUIDs sont définis par l'application principale, d'autres le sont par le
plugin.<P>Un UUID est une valeur sur 128-bits dont l'unicité est garantie. Il peut 
être représenté sous deux formes différentes: sous forme d'octets ou sous 
forme de chaîne de caractères. Sous forme d'octets, il s'agit d'une structure
C définie dans les Core Foundations (<I>CFUUIDBytes</I>
dans le fichier d'en-tête <I>CFUUID.h</I>). L'écriture sous forme de chaîne est 
une convention pour faciliter la lecture: il s'agit d'une chaîne ASCII 
séparée par des tirets qui est utilisée, par exemple, dans le fichier de liste 
de propriétés du plugin (voir la section 
<A HREF="#plugplist"> Liste de propriétés du plugin</A> ci-dessous).<P><H4><A NAME="M5"></A>Les UUIDs de Rezilla</H4>
Rezilla définit deux UUIDs pour identifier respectivement le type du plugin
et la fonction dite de fabrication (<I>factory function</I>) qui
implémente l'interface. Ces valeurs sont définies dans le fichier d'en-tête <I>RezillaPluginInterface.h</I> au moyen de valeurs symboliques:
<UL>
	<LI> <I>kRezillaPluginEditorTypeID</I> est l'UUID du service d'édition de 
ressources. 
C'est un identificateur unique qui indique que l'on a affaire à un plugin 
d'édition pour Rezilla plutôt qu'un plugin destiné, par exemple, à iMovie 
ou iDVD.<P>	<LI> <I>kRezillaPluginEditorInterfaceVs1</I> est l'UUID caractérisant
l'interface courante qui définit le type précédent. Son nom se termine en
<I>Vs1</I> pour souligner qu'il s'agit de la première version d'interface 
et qu'il pourrait y en avoir d'autres par la suite (sans doute pour 
ajouter de nouvelles fonctionnalités). Quoi qu'il en soit, dans la version 
1.1 de Rezilla, il n'y a qu'un seul type et une seule interface pour ce 
type.
</UL>
Les UUIDs sont définis comme ceci:
<PRE>
	#define kRezillaPluginEditorTypeID (CFUUIDGetConstantUUIDWithBytes(NULL,0x30,0x6A,0x0E,0xF3,0x20,0x6E,0x11,0xDA,0x83,0x20,0x00,0x0A,0x95,0xB1,0xFF,0x7C))
	#define kRezillaPluginEditorInterfaceVs1 (CFUUIDGetConstantUUIDWithBytes(NULL,0x30,0x6A,0xE1,0x67,0x20,0x6E,0x11,0xDA,0x83,0x20,0x00,0x0A,0x95,0xB1,0xFF,0x7C))
</PRE>
ce qui s'écrit, sous forme de chaîne:
<PRE>
	306A0EF3-206E-11DA-8320-000A95B1FF7C
	306AE167-206E-11DA-8320-000A95B1FF7C
</PRE><P><H4><A NAME="M6"></A>Les UUIDs des fabriques</H4>
Le plugin doit fournir des UUIDs pour toutes les implémentations 
d'interfaces qu'il contient. L'implémentation est réalisée par une 
fonction de fabrication ou fabrique (<I>factory function</I>). Ces 
fabriques sont déclarées dans la liste de propriétés du plugin et 
définies dans le plugin lui-même.
Le plugin <I>RezillaImage</I>, par exemple, supporte le type d'édition de 
ressources  de 
Rezilla et l'interface associée, il lui faut donc définir un seul UUID de 
fabrique. Son code source en C contient l'instruction suivante:
<PRE>
	#define kRezillaImageFactoryID (CFUUIDGetConstantUUIDWithBytes(NULL,0x09,0x05,0xF8,0x36,0xA2,0x0C,0x11,0xDA,0xBC,0x6C,0x00,0x0A,0x95,0xB1,0xFF,0x7C))
</PRE>
et sa liste de propriétés déclare la même valeur sous forme de chaîne:
<PRE>
	0905F836-A20C-11DA-BC6C-000A95B1FF7C
</PRE>
Dans le cas où il existe plusieurs interfaces, chaque interface (et donc
chaque fabrique) doit avoir un UUID.<P><H4><A NAME="M7"></A>Créer un UUID</H4>
Il existe un outil de ligne de commande simple appelé <B>uuidgen</B>, 
fourni avec les <I>Developers Tools</I> d'Apple, qui génère des UUIDs. Voici un 
exemple de son utilisation (à exécuter dans une fenêtre de Terminal):
<PRE>
	shell> uuidgen
	9A347042-427C-11DB-9237-000A95B1FF7C
</PRE><P>Le kit de développement de Rezilla (<I>Rezilla SDK</I>) fournit aussi un
outil un peu plus élaboré appelé <B>mkuuid</B>. Avec mkuuid, on peut
spécifier le nombre d'UUIDs à générer et le résultat renvoie les UUIDs à la
fois sous forme d'octets (à utiliser dans du code C) et sous forme de
chaîne (à utiliser dans la liste de propriétés). Voici un exemple de son
utilisation:
<PRE>
	shell> mkuuid 2
	UUID as bytes: (NULL,0xC1,0x37,0x86,0xB4,0x42,0x7C,0x11,0xDB,0xA0,0xC4,0x00,0x0A,0x95,0xB1,0xFF,0x7C)
	UUID as string: "C13786B4-427C-11DB-A0C4-000A95B1FF7C"
	
	UUID as bytes: (NULL,0xC1,0x38,0x2C,0x85,0x42,0x7C,0x11,0xDB,0xA0,0xC4,0x00,0x0A,0x95,0xB1,0xFF,0x7C)
	UUID as string: "C1382C85-427C-11DB-A0C4-000A95B1FF7C"
</PRE><P><A NAME="plugplist"></A>
<H3><A NAME="M8"></A>Liste de propriétés du plugin</H3><P>Le fichier <I>Info.plist</I> stocke des données et des informations utiles
relatives au plugin. Il utilise un format XML: certaines clés sont
utilisées par le Finder et le Système, d'autres sont utilisés par Rezilla
lui-même.<P><H4><A NAME="M9"></A>Les clés du Système</H4>
Les clés définies par le Système sont les balises usuelles que l'on trouve 
dans les applications construites sous forme de paquetage (<I>application bundle</I>).
Dans le cas du plugin <I>RezImage</I>, par exemple, on trouve les paires 
clé/valeur suivantes:
<P><TABLE BORDER=0 CELLPADDING=1>
<TR><TD><B>Clé</B></TD><TD><B>Valeur</B></TD></TR>
<TR><TD>CFBundleIdentifier</TD><TD><I>net.sourceforge.rezilla.RezImagePlugin</I></TD></TR>
<TR><TD>CFBundleName</TD><TD><I>RezImagePlugin</I></TD></TR>
<TR><TD>CFBundleShortVersionString</TD><TD><I>RezImagePlugin 0.1</I></TD></TR>
<TR><TD>CFBundlePackageType</TD><TD><I>BNDL</I></TD></TR>
<TR><TD>CFBundleSignature</TD><TD><I>Rzil</I></TD></TR>
<TR><TD>CFBundleExecutable</TD><TD><I>RezImagePlugin</I></TD></TR>
<TR><TD>CFBundleVersion</TD><TD><I>0.1</I></TD></TR>
<TR><TD>CFBundleIconFile</TD><TD><I>RezillaPlugin.icns</I></TD></TR>
<TR><TD>CFBundleDevelopmentRegion</TD><TD><I>English</I></TD></TR>
<TR><TD>CFBundleInfoDictionaryVersion</TD><TD><I>6.0</I></TD></TR>
<TR><TD>LSRequiresCarbon</TD><TD><I>yes</I></TD></TR>
</TABLE></P><P>Le sous-dossier <I>Resources</I>, à l'intérieur du paquetage du plugin,
peut contenir un fichier d'icone (fichier avec l'extension <TT>.icns</TT>).
Si ce fichier d'icone est déclaré dans la liste <I>Info.plist</I> sous la
clé <I>CFBundleIconFile</I>, l'image sera affichée par Rezilla dans le
panneau <I>Plugin Info</I> appelé par la commande <I>Plugins...</I> du
menu <I>File</I>.<P><H4><A NAME="M10"></A>Les clés de CFPlugin </H4>
Certaines sont requises par l'interface de programmation <I>CFPlugin</I>:
<UL>
	<LI> <I>CFPlugInDynamicRegistration</I> détermine la méthode
d'enregistrement adoptée par le plugin (statique ou dynamique). Rezilla
utilise l'enregistrement statique, la valeur doit donc toujours être <I>no</I>:
<PRE>
	&lt;key&gt;CFPlugInDynamicRegistration&lt;/key&gt;
	&lt;string&gt;NO&lt;/string&gt;
</PRE><P>	<LI> <I>CFPluginNameString</I> est optionnel et contient le nom du plugin. 
Par exemple:
<PRE>
	&lt;key&gt;CFPluginNameString&lt;/key&gt;
	&lt;string&gt;RezImagePlugin&lt;/string&gt;
</PRE><P>	<LI> <I>CFPlugInUnloadFunction</I> définit la fonction à appeler 
lorsque le code d'un plugin doit être désinstallé.
Cette valeur peut être laissée vide:
<PRE>
	&lt;key&gt;CFPlugInUnloadFunction&lt;/key&gt;
	&lt;string&gt;&lt;/string&gt;
</PRE><P>	<LI> <I>CFPlugInTypes</I> est utilisé pour l'enregistrement statique. Sa
valeur est un dictionnaire dont les clés sont des UUIDs de type de plugin
(voir la section <A HREF="#pluguuids"> Les UUIDs de plugin</A>) et dont les
valeurs sont des tableaux d'UUIDs de fabriques. L'UUID de type du plugin
est défini par Rezilla: il est défini par la constante symbolique ((v
kRezillaPluginEditorTypeID</TT> dans le fichier d'en-tête <I>RezillaPluginInterface.h</I> et sa valeur sous forme de chaîne est:
<PRE>
	306A0EF3-206E-11DA-8320-000A95B1FF7C
</PRE>
Les fonctions qui instancient une interface particulière sont appelées des
<I>fabriques</I>. Les UUIDs de ces fabriques sont définis par le plugin:
un UUID de fabrique par interface. Dans le cas du plugin <I>RezImagePlugin</I>, le fichier <I>Info.plist</I> définit ainsi:
<PRE>
	&lt;key&gt;CFPlugInTypes&lt;/key&gt;
	&lt;dict&gt;
		&lt;key&gt;306A0EF3-206E-11DA-8320-000A95B1FF7C&lt;/key&gt;
		&lt;array&gt;
			&lt;string&gt;0905F836-A20C-11DA-BC6C-000A95B1FF7C&lt;/string&gt;
		&lt;/array&gt;
	&lt;/dict&gt;
</PRE>
Cela signifie que le type identifié par l'UUID
306A0EF3-206E-11DA-8320-000A95B1FF7C (c'est-à-dire la constante
<I>kRezillaPluginEditorTypeID</I> définie par Rezilla) ne possède actuellement
qu'une seule interface, identifiée par l'UUID
0905F836-A20C-11DA-BC6C-000A95B1FF7C, attribué par le plugin.<P>	<LI> <I>CFPlugInFactories</I> est utilisé pour l'enregistrement statique.
Sa valeur est un dictionnaire dont les clés sont des UIIDs de fabriques
exprimés sous forme de chaînes et dont les valeurs sont les noms des
fabriques. Cette clé est très importante: elle indique le nom de la
fonction à appeler pour instancier une interface particulière. Le
dictionnaire établit une correspondance entre interfaces et noms de
fonctions. Le plugin, en tant que bibliothèque dynamique (<I>dynamic
library</I>), doit donner la définition de ces fonctions. Dans le cas du
plugin <I>RezImagePlugin</I>, le fichier <I>Info.plist</I> définit ainsi:
<PRE>
	&lt;key&gt;CFPlugInFactories&lt;/key&gt;
	&lt;dict&gt;
		&lt;key&gt;0905F836-A20C-11DA-BC6C-000A95B1FF7C&lt;/key&gt;
		&lt;string&gt;RezillaImageFactory&lt;/string&gt;
	&lt;/dict&gt;
</PRE>
On reconnaît ici l'UUID (0905F836-A20C-11DA-BC6C-000A95B1FF7C) vu au 
paragraphe précédent et attribué par le plugin pour désigner la fabrique 
qui implémente le service d'édition. La valeur correspondante est
<I>RezillaImageFactory</I>: c'est le nom de la fonction que Rezilla devra 
invoquer au moment de charger le plugin. Cette fonction doit être définie 
dans la bibliothèque dynamique.<P></UL><P><H4><A NAME="M11"></A>Les clés de Rezilla</H4>
Rezilla s'attend à trouver deux clés supplémentaires dans le fichier
<I>Info.plist</I>:
<UL>
	<LI> la clé <I>RezillaPluginEditTypes</I> est obligatoire. C'est là que le
plugin déclare les types de ressources qu'il est capable d'éditer. La
valeur est un tableau de codes à quatre caractères (les types de
ressources). Par exemple, le plugin <I>RezImagePlugin</I> reconnaît 12
types de ressources qui sont déclarés comme ceci:<P><PRE>
	&lt;key&gt;RezillaPluginEditTypes&lt;/key&gt;
	&lt;array&gt;
		&lt;string&gt;JPEG&lt;/string&gt;
		&lt;string&gt;jpeg&lt;/string&gt;
		&lt;string&gt;JPG &lt;/string&gt;
		&lt;string&gt;jpg &lt;/string&gt;
		&lt;string&gt;TIFF&lt;/string&gt;
		&lt;string&gt;tiff&lt;/string&gt;
		&lt;string&gt;GIF &lt;/string&gt;
		&lt;string&gt;gif &lt;/string&gt;
		&lt;string&gt;PNG &lt;/string&gt;
		&lt;string&gt;png &lt;/string&gt;
		&lt;string&gt;BMP &lt;/string&gt;
		&lt;string&gt;bmp &lt;/string&gt;
	&lt;/array&gt;
</PRE><P>	<LI> la clé <I>RezillaPluginRole</I> définit le rôle du plugin. Dans
 la version 1.1, deux valeurs sont possibles: <I>Editor</I> ou <I>Viewer</I>.
<PRE>
	&lt;key&gt;RezillaPluginRole&lt;/key&gt;
	&lt;string&gt;Editor&lt;/string&gt;
</PRE>
Cette clé est optionnelle et n'est actuellement pas utilisée par Rezilla.<P></UL><P><H3><A NAME="M12"></A>L'interface du plugin</H3><P>Les membres de l'interface du plugin sont définis dans le fichier d'en-tête <I>RezillaPluginInterface.h</I> qui se trouve dans le kit de développement de 
Rezilla (<I>Rezilla SDK</I>). Ce fichier doit être inclus dans le code
source du plugin. Il définit l'interface elle-même ainsi que quelques 
autres structures et énumérations qui régissent la communication entre 
l'application principale et les plugins.<P><H4><A NAME="M13"></A>La structure de l'interface</H4><P>L'interface est définie comme une structure composée de pointeurs de 
fonctions. C'est la liste de toutes les fonctions que le plugin doit 
définir pour implémenter l'interface. Ce sont les fonctions que Rezilla 
invoquera pour accomplir les différentes tâches relatives à l'édition 
d'une ressource.
<PRE>
typedef struct SPluginEditorInterface {
    IUNKNOWN_C_GUTS;
    Boolean  (*AcceptResource)(void *myInstance, ResType inType, short inID, Handle inDataH, RezPlugInfo * outInfo);
    OSErr    (*EditResource)(RezPlugRef inPlugref, RezHostInfo inInfo);
    Handle   (*ReturnResource)(RezPlugRef inPlugref, Boolean * outRelease, OSErr * outError);
    OSErr    (*RevertResource)(RezPlugRef inPlugref, Handle inDataH);
    Boolean  (*IsModified)(RezPlugRef inPlugref);
    void     (*CleanUp)(RezPlugRef inPlugref);
    void     (*Refresh)(RezPlugRef inPlugref);
    OSErr    (*ResizeBy)(RezPlugRef inPlugref, SInt16 inWidthDelta, SInt16 inHeightDelta);
    void     (*HandleMenu)(RezPlugRef inPlugref, MenuRef menu, SInt16 inMenuItem);
    void     (*HandleClick)(RezPlugRef inPlugref, const EventRecord * inMacEvent, Point inPortCoords);
    void     (*HandleKeyDown)(RezPlugRef inPlugref, const EventRecord * inKeyEvent);
    Boolean  (*HandleCommand)(RezPlugRef inPlugref, SInt16 inCommand);
}
</PRE><P>Cette structure donne les protopypes des fonctions. Le symbole 
<TT>IUNKNOWN_C_GUTS</TT> est une macro définie dans le fichier d'en-tête 
<I>CFPlugInCOM.h</I> et qui se développe en trois prototypes de fonctions
qui doivent impérativement figurer dans l'interface: <I>QueryInterface, 
AddRef</I>, et <I>Release</I>. Elles forment la base de l'architecture 
COM: n'importe quel plugin qui se conforme à ce modèle doit les définir. 
C'est là que les vérifications préliminaires ont lieu: par exemple, 
l'application identifie le plugin et vérifie que les UUIDs sont bien ceux 
que l'on attend. Voici les prototypes des trois fonctions COM:<P><PRE>
	HRESULT (*QueryInterface)(void *thisPointer, REFIID iid, LPVOID *ppv); \
	ULONG (*AddRef)(void *thisPointer); \
	ULONG (*Release)(void *thisPointer)
</PRE><P>Toutes les autres fonctions sont requises par Rezilla qui compte sur le plugin
pour les fournir. À l'exception de <I>AcceptResource</I>, le premier 
argument de toutes ces fonctions est un <I>RezPlugRef</I>: il s'agit 
d'une référence attribuée par le plugin à toute session d'édition de 
ressource, lors de la transaction initiale. Plus précisément, un
<I>RezPlugRef</I> est un pointeur sur des données clientes correspondant 
à la ressource à éditer: c'est cette référence qui identifie la ressource 
concernée ainsi que les données qui y sont attachées, car un plugin peut 
avoir plusieurs ressources à gérer simultanément. Rezilla n'intervient pas 
dans ces données clientes et se contente de passer le pointeur <I>RezPlugRef</I> dans tous 
les appels à une fonction du plugin. 
Le type d'un <I>RezPlugRef</I> est défini dans le fichier d'en-tête 
<I>RezillaPluginInterface.h</I> comme ceci:
<PRE>
	typedef void *	RezPlugRef;
</PRE><P>Lorsque le plugin est invoqué pour le première fois, Rezilla le charge en 
utilisant les fonctions adéquates de l'API CFPlugin. C'est à ce moment que 
la fonction de fabrication de l'interface est appelée: le nom de cette 
fonction est trouvé, comme indiqué précédemment dans la section 
<A HREF="#plugplist">Liste de propriétés du plugin</A>, dans le fichier de liste 
de propriétés <I>Info.plist</I>.<P><H4><A NAME="M14"></A>Interaction avec le plugin</H4>
Lorsque Rezilla doit éditer une ressource au moyen d'un plugin, une
transaction préliminaire a lieu entre les deux. Cette transaction s'exécute
en deux étapes qui font intervenir les fonctions <I>AcceptResource</I> et
<I>EditResource</I> successivement:
<OL>
	<LI> Rezilla invoque tout d'abord la fonction <I>AcceptResource</I> 
afin de demander au plugin s'il accepte d'éditer la ressource: il lui 
transmet le type, le numéro et l'adresse des données de la ressource afin 
qu'il puisse déterminer sa réponse. Si le plugin accepte la ressource, il 
remplit une structure de type <I>RezPlugInfo</I> que Rezilla lui a 
également passée en argument et dans laquelle il peut faire un certain 
nombre de requêtes: il peut par exemple demander à Rezilla d'insérer un ou
plusieurs menus dans la barre de menus.
C'est à ce moment que le plugin peut attribuer une référence <I>RezPlugRef</I>, c'est-à-dire un pointeur sur des données clientes, à cette 
nouvelle session d'édition et la transmettre à Rezilla qui, par la suite, la 
fera figurer dans toutes les autres fonctions de l'interface.<P>	<LI> après que Rezilla aura reçu l'acceptation du plugin et les requêtes de
celui-ci, la fonction <I>EditResource</I> sera invoquée. Par le biais de
cette fonction, le plugin reçoit une structure de type <I>RezHostInfo</I>
contenant des informations fournies par Rezilla: un pointeur <I>WindowRef</I> pour
identifier la fenêtre d'édition fournie par l'application, des pointeurs
<I>MenuRef</I> si jamais le plugin avait demandé l'insertion de menus, etc.
</OL><P>À ce stade, le plugin peut maintenant faire son travail d'édition de la
ressource. Il peut par exemple créer des contrôles et des éléments
graphiques, installer au besoin des CarbonEvents sur ces contrôles, etc. La
fenêtre est construite en mode composite (<I>compositing mode</I>) ce qui
permet d'utiliser pleinement le modèle HIViews de dessin de l'interface 
graphique.<P>On notera dependant qu'il n'y a aucune obligation à utiliser des
CarbonEvents; toutes les actions et événements déclenchés par l'utilisateur
sont passés à Rezilla sous la forme d'un EventRecord dans les fonctions
suivantes définies dans l'interface: <I>HandleMenu, HandleClick,
HandleKeyDown</I> et <I>HandleCommand</I>.<P>Lorsque vient le moment de sauvegarder les modifications faites dans la ressource
 (par exemple lorsque l'utilisateur clique sur le bouton <I>Save</I> 
ou tente de fermer la fenêtre), 
Rezilla invoque la fonction <I>ReturnResource</I> afin que le plugin 
renvoie les données modifiées, puis la fonction <I>CleanUp</I> 
afin qu'il puisse terminer sa session d'édition:
<UL>
	<LI> la fonction <I>ReturnResource</I> renvoie une <I>handle</I> sur les
données modifiées. Elle comporte aussi un argument booléen <I>releaseIt</I> qui indique à Rezilla qui est propriétaire de cette <I>handle</I> et
qui devra donc libérer la mémoire qu'elle occupe. Si cet argument est fixé
à la valeur <I>true</I> c'est Rezilla qui est responsable de libérer la
mémoire, autrement le plugin devra s'en charger.<P>	<LI> lorsque la fonction <I>CleanUp</I> est appelée, le plugin exécute 
toutes les tâches de post-édition qu'il juge nécessaire, libère la mémoire 
qu'il a allouée, etc.<P></UL><P>Si l'utilisateur clique sur le bouton <I>Revert</I> (lorsqu'il y en a
un!), Rezilla invoque la fonction <I>RevertResource</I>: les données
auxquelles il faut revenir sont fournies par l'intermédiaire de l'argument
<I>inDataH</I>, ce qui signifie en particulier que le plugin n'a pas à se
préoccuper de garder une copie des données originales.<P><H4><A NAME="M15"></A>Les requêtes du plugin</H4><P>Cette section donne plus de détails concernant les requêtes formulées par 
le plugin dans la fonction <I>AcceptResource</I>. La structure <I>RezPlugInfo</I> est définie comme ceci:
<PRE>
typedef struct RezPlugInfo {
    RezPlugRef    plugref;
    UInt32        attributes;
    Rect          winbounds;
    UInt8         menucount;
    MenuID *      menuIDs;
    OSErr         error;
}
</PRE><P>Le membre le plus important de cette structure est <I>attributes</I>:
il s'agit d'une valeur additive de type UInt32, somme de différents
drapeaux qui déterminent diverses caractéristiques de la fenêtre d'édition qui 
sera fournie par Rezilla ainsi que les commandes de base de Rezilla
qui seront supportées par le plugin. Les valeurs de ces drapeaux sont 
définies dans une énumération <I>RezillaPluginFlags</I> déclarée 
dans le fichier d'en-tête <I>RezillaPluginInterface.h</I>:
<PRE>
enum RezillaPluginFlags {
    kPluginNoAttributes             = 0L,
    
    kPluginEditorHasSaveButton      = (1L << 0),
    kPluginEditorHasCancelButton    = (1L << 1),
    kPluginEditorHasRevertButton    = (1L << 2),
    kPluginEditorHasLockIcon        = (1L << 3),
    kPluginEditorHasNameField       = (1L << 4),
    kPluginEditorStandardControls   = (kPluginEditorHasSaveButton 
                                   | kPluginEditorHasCancelButton 
                                   | kPluginEditorHasRevertButton 
                                   | kPluginEditorHasLockIcon),
    
    kPluginWinHasCollapseBox        = (1L << 5),
    kPluginWinIsResizable           = (1L << 6),
    
    kPluginSupportCut               = (1L << 10),
    kPluginSupportCopy              = (1L << 11),
    kPluginSupportPaste             = (1L << 12),
    kPluginSupportClear             = (1L << 13),
    kPluginSupportSelectAll         = (1L << 14),
    kPluginSupportFind              = (1L << 15),
    kPluginSupportFindNext          = (1L << 16),
    kPluginSupportImport            = (1L << 17),
    kPluginSupportExport            = (1L << 18),
    kPluginSupportEditCommands      = (kPluginSupportCut 
                                   | kPluginSupportCopy 
                                   | kPluginSupportPaste 
                                   | kPluginSupportClear)
}
</PRE><P>Le membre <I>winbounds</I> est une structure Rect indiquant la position et
dimension de la fenêtre d'édition: elle est exprimée en coordonnées
globales et correspond à la structure entière de la fenêtre, autrement les
dimensions qui sont habituellement passées à la fonction <I>CreateWindow</I>. Rezilla fournit toujours une fenêtre d'édition qui peut être équipée
d'un certain nombre d'éléments de base tels que des boutons <I>Save</I> et
<I>Cancel</I>. Le plugin n'a pas à se préoccuper de surveiller ces
contrôles: ils sont gérés par l'application principale. Le plugin doit
simplement décider, au moyen des drapeaux adéquats, lesquels de ces
contrôles doivent figurer dans la fenêtre. Par exemple, on ajoutera le
drapeau <I>kPluginEditorHasRevertButton</I> aux attributs si l'on souhaite
avoir un bouton <I>Revert</I> dans la fenêtre.<P>Le membre <I>menucount</I> indique combien de menus sont nécessaires au
plugin (éventuellement 0). Si le plugin définit des menus, il doit passer
un tableau des MenuIDs correspondants dans le membre <I>menuIDs</I> de la
structure. Ces MenuIDs sont les numéros de ressources de type 'MENU' qui
devront se trouver dans le fichier de ressources du plugin: ce fichier de
ressources se trouve dans le sous-dossier <I>Resources</I> à l'intérieur
du paquetage (<I>bundle</I>) dans lequel se trouve le plugin, comme il a été expliqué
à la section <A HREF="#plugbundle">Anatomie du plugin</A> ci-dessus.<P>Dans le cas où le plugin n'accepte pas d'éditer une resource, il doit
renvoyer la valeur booléenne <I>false</I> comme valeur de retour de la
fonction <I>AcceptResource</I> et il n'est alors pas nécessaire de remplir
la structure de requêtes. Si une erreur se produit, le plugin peut
toutefois passer un code d'erreur dans le membre <I>error</I> de la
structure <I>RezPlugInfo</I>.<P><H4><A NAME="M16"></A>Les commandes supportées</H4>
Les menus de base de Rezilla (<I>File, Edit, Resources</I>) comportent des
commandes qui ne sont pas toujours activées: cela dépend du contexte. Par
exemple, la commande <I>Export</I> n'a de sens que dans certaines
circonstances ou avec certains types de ressources: de même, un plugin peut
décider de supporter cette commande ou pas. Les commandes ainsi supportées
par le plugin sont déclarées dans les attributs lors de la transaction
préliminaire comme il a été expliqué à la section précédente: si la
commande <I>Export</I> est supportée par le plugin, le drapeau <I>kPluginSupportExport</I> doit être ajouté aux attributs. Si ce drapeau
n'est pas mis, l'article de menu correspondant sera désactivé.<P>Par la suite, lorsque la commande <I>Export</I> du menu <I>File</I> est
invoquée par l'utilisateur, Rezilla appelle la fonction <I>HandleCommand</I> 
avec un numéro de commande correspondant afin que le plugin puisse
réagir en conséquence. Les numéros de commandes sont définis dans
l'énumération <I>RezillaPluginCmdIDs</I> déclarée dans le fichier
d'en-tête <I>RezillaPluginInterface.h</I>:
<PRE>
enum RezillaPluginCmdIDs {
    kPluginCommandCut        = 1,
    kPluginCommandCopy,
    kPluginCommandPaste,
    kPluginCommandClear,
    kPluginCommandSelectAll,
    kPluginCommandFind,
    kPluginCommandFindNext,
    kPluginCommandImport,
    kPluginCommandExport
}
</PRE><P><H4><A NAME="M17"></A>Informations de l'hôte</H4><P>La structure <I>RezHostInfo</I>  est définie comme ceci:
<PRE>
typedef struct RezHostInfo {
    CFBundleRef  bundleref;
    short        refnum;
    WindowRef    winref;
    UInt8        menucount;
    MenuRef *    menurefs;
    Rect         editrect;
    Boolean      readonly;
}
</PRE><P>C'est là que Rezilla passe des informations à destination du plugin. <P>Le membre <I>bundleref</I> de la structure est passé à titre de facilité:
c'est une référence de type <I>CFBundleRef</I> au paquetage du plugin pour le cas
où le plugin aurait besoin de trouver quelque chose à l'intérieur de sa
propre structure (des fichiers de localisation par exemple).<P>Le membre <I>refnum</I> est le numéro de référence de la table de 
ressources en mémoire à laquelle appartient la ressource en cours 
d'édition. Cela donne accès pour le plugin à diverses fonctions du 
Gestionnaire de ressources (<I>Resource Manager</I>): le plugin pourrait 
avoir besoin de trouver d'autres ressources dans la même table par 
exemple.<P>Le membre <I>winref</I> est le pointeur de type <I>WindowRef</I> de la fenêtre d'édition 
créée par Rezilla.<P>Le membre <I>menucount</I> indique combien de menus ont été créés par 
Rezilla. Ce devrait être le même nombre que celui demandé par le plugin 
dans la structure <I>RezillaPluginFlags</I>.
Le membre <I>menurefs</I> est un tableau de pointeurs de type <I>MenuRef</I>
correspondant aux différents menus.<P>Le membre <I>editrect</I> est une structure de type <I>Rect</I> indiquant les
coordonnées de la zone de contenu de la fenêtre d'édition qui peut être
utilisée par le plugin pour installer ses contrôles et éléments graphiques
sans dessiner par dessus des parties installées par Rezilla (comme par
exemple l'en-tête de la fenêtre ou la zone inférieure contenant les boutons
<I>Save</I> et <I>Cancel</I>). Ce <I>Rect</I> est exprimé dans le système de
coordonnées de la fenêtre.<P>Le membre <I>readonly</I> indique si la table à laquelle la ressource 
appartient est en lecture seule. Si elle l'est, il n'y a pas lieu 
d'autoriser des modifications: dans ce cas le plugin se comporte comme un simple 
visualisateur de contenu.<P><H4><A NAME="M18"></A>Codes d'erreur</H4><P>Rezilla définit des codes pour les principales erreurs susceptibles de se 
produire au cours d'une session d'édition par plugin. Ces codes commencent 
à la valeur 5000:
<PRE>
enum RezillaPluginErrors {
    plugErr_Generic                = 5000,    
    plugErr_InitializationFailed,
    plugErr_UnsupportedType,
    plugErr_UnsupportedID,
    plugErr_InvalidData,
    plugErr_UnsupportedResourceFormat,
    plugErr_UnsupportedResourceVersion,
    plugErr_EditResourceFailed,
    plugErr_ReturnResourceFailed,
    plugErr_RevertResourceFailed,
    plugErr_CantResizeWindow,
    plugErr_CantHandleMenuCommand,
	plugErr_CantEditEmptyResource,
    plugErr_LastError
}
</PRE><P><H3><A NAME="M19"></A>Le plugin Sample</H3><P>Cette section commente le code du plugin <B>Sample</B> fourni avec le kit
de développement de Rezilla (<I>Rezilla SDK</I>) pour servir à la fois
d'exemple et de modèle pour la création d'un plugin pour Rezilla. Un
fichier de projet XCode est aussi fourni. Le plugin <B>Sample</B> met en
relief les divers aspects des tâches de programmation nécessaires pour la
création d'un plugin Rezilla. Le code source lui-même contient par
ailleurs des commentaires détaillés.<P>Pour en apprendre plus sur les plugins Rezilla, on pourra aussi consulter
le code source du plugin <B>RezImage</B> qui est un véritable éditeur
présent dans la version 1.1 de Rezilla. Il permet d'éditer des ressources
d'images ('jpeg', 'tiff', 'gif ', etc.). Son code source fait partie de la
distribution du code source de Rezilla.<P>Le plugin <B>Sample</B> a pour but d'éditer des resources de type 'PStr'
ou 'STR '. Ce sont des ressources très simples qui contiennent uniquement
une chaîne de Pascal. Le plugin affiche cette chaîne dans un champ
d'édition afin de permettre à l'utilisateur de la lire et de la modifier.
Par ailleurs le plugin installe un menu avec deux commandes qui peuvent
aussi agir sur la chaîne (elles ne font rien de vraiment utile, il s'agit
simplement d'un exemple).<P><H4><A NAME="M20"></A>Les fichiers source de Sample </H4><P>Le dossier <I>SamplePlugin</I> du kit de développement de Rezilla contient
les fichiers suivants:
<UL>
	<LI> <I>RezSamplePlugin.xcode</I> est le projet XCode permettant de 
construire le plugin <P>	<LI> <I>RezSamplePlugin.c</I> est le fichier source principal définissant 
les fonctions du plugin  <P>	<LI> <I>RezillaPluginInterface.h</I> est le fichier d'en-tête fourni par 
Rezilla dans lequel l'interface du plugin et les données publiques sont 
déclarées. Ce fichier ne doit pas être modifié et sera simplement inclus 
dans le code source<P>	<LI> <I>RezSamplePlugin.rsrc</I> est le fichier de resources du plugin<P>	<LI> <I>Info.plist</I> est la liste de propriétés du plugin<P>	<LI> <I>English.lproj</I> est un dossier localisé contenant quelques 
chaînes affichées par la commande <I>Lire les informations</I> du Finder
</UL><P><H4><A NAME="M21"></A>L'UUID de Sample </H4><P>Le plugin doit définir un seul UUID correspondant à l'unique fonction de 
fabrication (<I>factory</I>). Cet UUID peut être créé avec la commande
 <I>genuuid</I> fournie avec les <I>Developer Tools</I> d'Apple ou avec 
l'utilitaire
<I>mkuuid</I> fourni dans le kit de développement de Rezilla.<P>La définition de l'UUID se trouve au début du fichier source 
<I>RezSamplePlugin.c</I>:
<PRE>
	#define kRezillaSampleFactoryID (CFUUIDGetConstantUUIDWithBytes(NULL,0x30,0x6B,0x89,0xA8,0x20,0x6E,0x11,0xDA,0x83,0x20,0x00,0x0A,0x95,0xB1,0xFF,0x7C))
</PRE><P><H4><A NAME="M22"></A>La liste de propriétés de Sample</H4><P>L'UUID mentionné au paragraphe précédent s'écrit sous forme de chaîne 
comme ceci: 
<PRE>
	306B89A8-206E-11DA-8320-000A95B1FF7C 
</PRE>
Il est utilisé dans le fichier <I>Info.plist</I> à deux endroits: en tant
que clé dans le dictionnaire <I>CFPlugInFactories</I> et en tant que
valeur dans le dictionnaire <I>CFPlugInTypes</I>:
<PRE>
	&lt;key&gt;CFPlugInFactories&lt;/key&gt;
	&lt;dict&gt;
		&lt;key&gt;306B89A8-206E-11DA-8320-000A95B1FF7C&lt;/key&gt;
		&lt;string&gt;RezSampleFactory&lt;/string&gt;
	&lt;/dict&gt;
	&lt;key&gt;CFPlugInTypes&lt;/key&gt;
	&lt;dict&gt;
		&lt;key&gt;306A0EF3-206E-11DA-8320-000A95B1FF7C&lt;/key&gt;
		&lt;array&gt;
			&lt;string&gt;306B89A8-206E-11DA-8320-000A95B1FF7C&lt;/string&gt;
		&lt;/array&gt;
	&lt;/dict&gt;
</PRE>
On notera que la clé (et non la valeur) dans le dictionnaire <I>CFPlugInTypes</I> est l'UUID identifiant le type de service assuré par le
plugin (c'est la constante <I>kRezillaPluginEditorTypeID</I> définie par
Rezilla). La valeur dans le dictionnaire <I>CFPlugInFactories</I> est le
nom de la fabrique, fonction de fabrication à invoquer pour instancier
l'interface du plugin: cette fonction (<I>RezSampleFactory</I>) est
définie dans le fichier source <I>RezSamplePlugin.c</I>.<P>Le fichier <I>Info.plist</I> déclare par ailleurs les types de ressources
supportés par le plugin ('PStr' et 'STR '):
<PRE>
	&lt;key&gt;RezillaPluginEditTypes&lt;/key&gt;
	&lt;array&gt;
		&lt;string&gt;PStr&lt;/string&gt;
		&lt;string&gt;STR &lt;/string&gt;
	&lt;/array&gt;
</PRE>
et le rôle du plugin:
<PRE>
	&lt;key&gt;RezillaPluginRole&lt;/key&gt;
	&lt;string&gt;Editor&lt;/string&gt;
</PRE><P>Les autres paires clé/valeur sont tout à fait usuelles et se comprennent
sans difficulté.<P><H4><A NAME="M23"></A>Le fichier de projet</H4><P>Le fichier de projet du plugin Sample <I>RezSamplePlugin.xcode</I> a été
créé avec la version 1.5 de XCode afin d'assurer une compatibilité maximale
avec d'anciennes versions du système OS X (Jaguar et Panther). Il
fonctionnera aussi avec des versions plus récentes de XCode: sous système
10.4 (Tiger), les versions 2.0 ou plus de XCode convertiront le fichier en
un fichier appelé <I>RezSamplePlugin.xcodeproj</I>.<P><H4><A NAME="M24"></A>Le code source </H4>
Le code C définissant les fonctions du plugin se trouve dans le fichier 
<I>RezSamplePlugin.c</I>.<P><H5><A NAME="M25"></A>Les structures de Sample </H5><P>Le plugin Sample définit deux structures afin de contrôler ses sessions 
d'édition:
<UL>
	<LI> la structure <B>SampleRec</B> permet de conserver des données au 
niveau de l'interface  (un pointeur sur l'interface et l'UUID de la 
fabrique) et de maintenir un compte de références afin de 
contrôler les allocations de mémoire
<PRE>
	typedef struct _SampleRec {
		SPluginEditorInterface *  _rezillaPlugInterface;
		CFUUIDRef                 _factoryID;
		UInt32                    _refCount;
	} SampleRec;
</PRE>
	<LI> la structure <B>SampleEditInfo</B> est créée pour chaque ressource 
éditée et stocke l'information associée 
<PRE>
	typedef struct SampleEditInfo {
		ResType      type;
		short        id;
		Handle       data;
		WindowRef    winref;
		ControlRef   controlref;
		Boolean      modified;
		Boolean      readonly;
	} SampleEditInfo;
</PRE>
</UL><P>Une table de fonctions est aussi créée: c'est une instance statique d'une 
structure <I>SPluginEditorInterface</I> (autrement dit la structure 
définie par Rezilla pour décrire l'interface) et contient le nom de toutes 
les fonctions de l'interface définies dans le plugin:
<PRE>
	static SPluginEditorInterface sSamplePlugFuncTable = {
			NULL,
			sample_QueryInterface,
			sample_AddRef,
			sample_Release,
			sample_AcceptResource,
			sample_EditResource,
			sample_ReturnResource,
			sample_RevertResource,
			sample_IsModified,
			sample_CleanUp,
			sample_Refresh,
			sample_ResizeBy,
			sample_HandleMenu,
			sample_HandleClick,
			sample_HandleKeyDown,
			sample_HandleCommand
	};
</PRE><P>Deux variables statiques contiennent l'identificateur et la référence du menu 
associé au plugin:
<PRE>
	static MenuID    sampleMenuID;
	static MenuRef   sampleMenuRef;
</PRE><P><H5><A NAME="M26"></A>La fabrique Sample</H5><P>La fonction <I>RezSampleFactory()</I> est appelée par Rezilla (par le 
biais de l'API
CFPlugin) lorsque le plugin est chargé pour la première fois. Cette 
fonction est connue grâce au fichier de liste de propriété <I>Info.plist</I>. Après avoir vérifié que le type du plugin est le bon 
(<I>kRezillaPluginEditorTypeID</I>), elle alloue de la mémoire pour la structure <I>SampleRec</I> et
l'initialise. Finalement elle déclare la fabrique par un appel à la 
fonction <I>CFPlugInAddInstanceForFactory()</I>.<P><H5><A NAME="M27"></A>Les fonctions COM </H5>
Le modèle COM requiert la définition de trois fonctions: <I>QueryInterface, AddRef</I> et <I>Release</I>. Celles-ci sont représentées
dans le plugin Sample par les fonctions <I>sample_QueryInterface(),
sample_AddRef()</I>, et <I>sample_Release()</I>.<P><UL>
	<LI> la fonction <I>QueryInterface</I> est l'endroit où l'interface 
souhaitée est 
référencée. Dans le cas de Rezilla (vs. 1.1), il y a une seule interface 
(une situation qui pourrait changer dans le futur si l'interface subit des 
ajouts). Cette fonction incrémente le compte de référence, et renvoie un 
pointeur sur l'instance du plugin.
	<LI> la fonction <I>AddRef</I> incrémente le compte de référence (<I>refcount</I>) chaque fois que l'interface est requise
	<LI> la fonction <I>Release</I> incrémente le compte de référence (<I>refcount</I>) et annule l'allocation de mémoire de la structure <I>SampleRec</I> 
dès que le compte atteint la valeur 0.
</UL><P><H5><A NAME="M28"></A>La transaction préliminaire</H5><P>La transaction préliminaire entre l'application principale et le plugin est
réalisée par les fonctions <I>sample_AcceptResource()</I> et
<I>sample_EditResource()</I>.<P>Dans la <I>fonction sample_AcceptResource()</I>, le plugin vérifie en premier 
lieu que le type de la ressource est bien un  des ceux qu'il attend et il 
alloue alors de la mémoire pour une structure  <I>SampleEditInfo</I> qui 
restera associée à la ressource éditée.
Le pointeur sur cette structure sera utilisé comme référence <I>RezPlugRef</I> et passé comme premier argument de toutes les autres 
fonctions de l'interface par Rezilla. L'information stockée dans cette 
structure sera ainsi disponible pour toutes ces fonctions.<P>La fonction <I>sample_AcceptResource()</I> remplit par ailleurs une structure 
<I>RezPlugInfo</I> passée par Rezilla en dernier argument afin de faire 
quelques requêtes auprès de l'application principale. En particulier, dans 
notre exemple, elle 
règle le champ d'attribut comme ceci:
<PRE>
	outInfo->attributes = kPluginEditorStandardControls | kPluginSupportEditCommands;
</PRE><P>Le symbole <I>kPluginEditorStandardControls</I> est une constante définie
par
Rezilla (dans <I>RezillaPluginInterface.h</I>) demandant que les 
contrôles standard soient présents dans la fenêtre d'édition (bouton <I>Save</I>, bouton <I>Cancel</I>, etc.). Le symbole
<I>kPluginSupportEditCommands</I> est une constante prédéfinie
destinée à activer les commandes du menu <I>Edit</I> de Rezilla 
(<I>Cut, Copy,
Paste</I>, etc.).
La fonction émet également une requête pour obtenir un menu:
<PRE>
	outInfo->menucount = 1;
	outInfo->menuIDs   = &sampleMenuID;
</PRE>
Le menu est défini au moyen d'une ressource 'MENU' dans le fichier de 
ressources 
<I>RezSamplePlugin.rsrc</I>. Il définit deux commandes
 (dont l'utilité reste douteuse, mais après tout il ne s'agit que d'un 
exemple): <I>Reverse string</I> et 
<I>Rotate string</I>.<P><H5><A NAME="M29"></A>Les fonctions de l'interface</H5><P>Les fonctions restantes, imposées par l'interface, sont:
<P><TABLE BORDER=0 CELLPADDING=1>
<TR><TD><I>sample_ReturnResource</I></TD></TR>
<TR><TD><I>sample_RevertResource</I></TD></TR>
<TR><TD><I>sample_IsModified</I></TD></TR>
<TR><TD><I>sample_CleanUp</I></TD></TR>
<TR><TD><I>sample_Refresh</I></TD></TR>
<TR><TD><I>sample_ResizeBy</I></TD></TR>
<TR><TD><I>sample_HandleMenu</I></TD></TR>
<TR><TD><I>sample_HandleClick</I></TD></TR>
<TR><TD><I>sample_HandleKeyDown</I></TD></TR>
<TR><TD><I>sample_HandleCommand</I></TD></TR>
</TABLE></P>
Leur définition ne pose pas de difficultés. <P><UL>
	<LI> La fonction <I>sample_HandleMenu()</I>
implémente les deux commandes de menu: la fonction passe la référence <I>MenuRef</I>
du menu ainsi que l'indice de la commande. <P>	<LI> La fonction <I>sample_HandleCommand()</I> 
est celle qui traite les commandes de base de Rezilla qui ont été activées 
à la demande du plugin au cours de la transaction préliminaire. Le code 
actuel du plugin Sample ne fait rien et l'implémentation est laissée en 
exercice au lecteur.<P>	<LI> La fonction <I>sample_IsModified()</I> est appelée périodiquement par 
Rezilla afin de savoir si la ressource éditée a subi des modifications et 
d'ajuster l'interface graphique en conséquence.<P>	<LI> La fonction <I>sample_CleanUp()</I> est appelée par Rezilla lorsque 
l'utilisateur ferme la fenêtre. Cette fonction libère la mémoire allouée 
initialement par le plugin pour la structure <I>SampleEditInfo</I>.<P>	<LI> La fonction <I>sample_ResizeBy()</I> est appelée lorsque l'utilisateur 
tente de redimensionner la fenêtre. Dans l'exemple présent elle renvoie le 
code d'erreur <I>plugErr_CantResizeWindow</I> car le drapeau <I>kPluginWinIsResizable</I>
ne figure pas dans les attributs initiaux, ce qui signifie que la fenêtre 
n'est pas redimensionnable.
</UL><P><H3><A NAME="M30"></A>Référence des plugins</H3><P>Voici, pour la référence, un résumé de l'interface de programmation (API)
permettant d'écrire des extensions pour Rezilla.<P>Un <I>RezPlugRef</I> est un pointeur sur des données définies par
l'extension. Une extension alloue habituellement de la mémoire pour une
structure contenant les informations nécessaires concernant la resource
éditée. Le <I>RezPlugRef</I> permet d'accéder à ces données dans n'importe
quelle fonction de l'interface: toutes ces fonctions le passent comme
premier argument.
<PRE>
	typedef void *	RezPlugRef;
</PRE><P><H4><A NAME="M31"></A>Structures</H4><P><H5><A NAME="M32"></A>SPluginEditorInterface</H5>
<PRE>
typedef struct SPluginEditorInterface {
    IUNKNOWN_C_GUTS;
    Boolean  (*AcceptResource)(void *myInstance, ResType inType, short inID, Handle inDataH, RezPlugInfo * outInfo);
    OSErr    (*EditResource)(RezPlugRef inPlugref, RezHostInfo inInfo);
    Handle   (*ReturnResource)(RezPlugRef inPlugref, Boolean * outRelease, OSErr * outError);
    OSErr    (*RevertResource)(RezPlugRef inPlugref, Handle inDataH);
    Boolean  (*IsModified)(RezPlugRef inPlugref);
    void     (*CleanUp)(RezPlugRef inPlugref);
    void     (*Refresh)(RezPlugRef inPlugref);
    OSErr    (*ResizeBy)(RezPlugRef inPlugref, SInt16 inWidthDelta, SInt16 inHeightDelta);
    void     (*HandleMenu)(RezPlugRef inPlugref, MenuRef menu, SInt16 inMenuItem);
    void     (*HandleClick)(RezPlugRef inPlugref, const EventRecord * inMacEvent, Point inPortCoords);
    void     (*HandleKeyDown)(RezPlugRef inPlugref, const EventRecord * inKeyEvent);
    Boolean  (*HandleCommand)(RezPlugRef inPlugref, SInt16 inCommand);
}
</PRE><P><H5><A NAME="M33"></A>RezPlugInfo</H5>
<PRE>
typedef struct RezPlugInfo {
    RezPlugRef    plugref;
    UInt32        attributes;
    Rect          winbounds;
    UInt8         menucount;
    MenuID *      menuIDs;
    OSErr         error;
}
</PRE><P><H5><A NAME="M34"></A>RezHostInfo</H5>
<PRE>
typedef struct RezHostInfo {
    CFBundleRef  bundleref;
    short        refnum;
    WindowRef    winref;
    UInt8        menucount;
    MenuRef *    menurefs;
    Rect         editrect;
    Boolean      readonly;
}
</PRE><P><H4><A NAME="M35"></A>Énumérations</H4><P><H5><A NAME="M36"></A>RezillaPluginFlags</H5>
<PRE>
enum RezillaPluginFlags {
    kPluginNoAttributes             = 0L,
    
    kPluginEditorHasSaveButton      = (1L << 0),
    kPluginEditorHasCancelButton    = (1L << 1),
    kPluginEditorHasRevertButton    = (1L << 2),
    kPluginEditorHasLockIcon        = (1L << 3),
    kPluginEditorHasNameField       = (1L << 4),
    kPluginEditorStandardControls   = (kPluginEditorHasSaveButton 
                                   | kPluginEditorHasCancelButton 
                                   | kPluginEditorHasRevertButton 
                                   | kPluginEditorHasLockIcon),
    
    kPluginWinHasCollapseBox        = (1L << 5),
    kPluginWinIsResizable           = (1L << 6),
    
    kPluginSupportCut               = (1L << 10),
    kPluginSupportCopy              = (1L << 11),
    kPluginSupportPaste             = (1L << 12),
    kPluginSupportClear             = (1L << 13),
    kPluginSupportSelectAll         = (1L << 14),
    kPluginSupportFind              = (1L << 15),
    kPluginSupportFindNext          = (1L << 16),
    kPluginSupportImport            = (1L << 17),
    kPluginSupportExport            = (1L << 18),
    kPluginSupportEditCommands      = (kPluginSupportCut 
                                   | kPluginSupportCopy 
                                   | kPluginSupportPaste 
                                   | kPluginSupportClear)
}
</PRE><P><H5><A NAME="M37"></A>RezillaPluginCmdIDs</H5>
<PRE>
enum RezillaPluginCmdIDs {
    kPluginCommandCut        = 1,
    kPluginCommandCopy,
    kPluginCommandPaste,
    kPluginCommandClear,
    kPluginCommandSelectAll,
    kPluginCommandFind,
    kPluginCommandFindNext,
    kPluginCommandImport,
    kPluginCommandExport
}
</PRE><P><H5><A NAME="M38"></A>RezillaPluginErrors</H5>
<PRE>
enum RezillaPluginErrors {
    plugErr_Generic                = 5000,    
    plugErr_InitializationFailed,
    plugErr_UnsupportedType,
    plugErr_UnsupportedID,
    plugErr_InvalidData,
    plugErr_UnsupportedResourceFormat,
    plugErr_UnsupportedResourceVersion,
    plugErr_EditResourceFailed,
    plugErr_ReturnResourceFailed,
    plugErr_RevertResourceFailed,
    plugErr_CantResizeWindow,
    plugErr_CantHandleMenuCommand,
	plugErr_CantEditEmptyResource,
    plugErr_LastError
}
</PRE><P><!--  logo SF -->
<!--  ------- -->
<HR>
<P> Last updated 2006-11-25 12:19:47
<HR>
<P> <I>Rezilla is hosted by</I> 
<A HREF="http://sourceforge.net"> <P><IMG SRC="http://sourceforge.net/sflogo.php?group_id=83267&amp;type=4 " ALT="SourceForge.net Logo" ALIGN=bottom></P></A><P>
</BODY>
</HTML>